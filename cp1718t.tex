\documentclass[a4paper]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{palatino}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{graphicx}
\usepackage{cp1718t}
\usepackage{subcaption}
\usepackage{adjustbox}
%================= lhs2tex=====================================================%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
\def\ana#1{\mathopen{[\!(}#1\mathclose{)\!]}}

%---------------------------------------------------------------------------

\title{
       	    Cálculo de Programas
\\
       	Trabalho Prático
\\
       	MiEI+LCC --- 2017/18
}

\author{
       	\dium
\\
       	Universidade do Minho
}


\date\mydate

\makeindex

\begin{document}

\maketitle

\begin{center}\large
\begin{tabular}{ll}
\textbf{Grupo} nr. & 13
\\\hline
a81047 & Catarina Machado
\\
a82339 & João Vilaça
\end{tabular}
\end{center}

\section{Preâmbulo}

A disciplina de \CP\ tem como objectivo principal ensinar
a progra\-mação de computadores como uma disciplina científica. Para isso
parte-se de um repertório de \emph{combinadores} que formam uma álgebra da
programação (conjunto de leis universais e seus corolários) e usam-se esses
combinadores para construir programas \emph{composicionalmente}, isto é,
agregando programas já existentes.

Na sequência pedagógica dos planos de estudo dos dois cursos que têm esta
disciplina, restringe-se a aplicação deste método à programação funcional
em \Haskell. Assim,
o presente trabalho prático coloca os alunos perante problemas
concretos que deverão ser implementados em \Haskell.
Há ainda um outro objectivo: o de ensinar a documentar programas e
a produzir textos técnico-científicos de qualidade.

\section{Documentação}
Para cumprir de forma integrada os objectivos enunciados acima vamos recorrer
a uma técnica de programa\-ção dita ``\litp{literária}'' \cite{Kn92}, cujo
princípio base é o seguinte:
\begin{quote}\em
Um programa e a sua documentação devem coincidir.
\end{quote}
Por outras palavras, o código fonte e a documentação de um programa deverão estar no
mesmo ficheiro.

O ficheiro \texttt{cp1718t.pdf} que está a ler é já um exemplo de \litp{programação
literária}: foi gerado a partir do texto fonte \texttt{cp1718t.lhs}\footnote{O
suffixo `lhs' quer dizer \emph{\lhaskell{literate Haskell}}.} que encontrará
no \MaterialPedagogico\ desta disciplina descompactando o ficheiro \texttt{cp1718t.zip}
e executando
\begin{Verbatim}[fontsize=\small]
    $ lhs2TeX cp1718t.lhs > cp1718t.tex
    $ pdflatex cp1718t
\end{Verbatim}
em que \href{https://hackage.haskell.org/package/lhs2tex}{\texttt\LhsToTeX} é
um pre-processador que faz ``pretty printing''
de código Haskell em \Latex\ e que deve desde já instalar executando
\begin{Verbatim}[fontsize=\small]
    $ cabal install lhs2tex
\end{Verbatim}
Por outro lado, o mesmo ficheiro \texttt{cp1718t.lhs} é executável e contém
o ``kit'' básico, escrito em \Haskell, para realizar o trabalho. Basta executar
\begin{Verbatim}[fontsize=\small]
    $ ghci cp1718t.lhs
\end{Verbatim}


\noindent Abra o ficheiro \texttt{cp1718t.lhs} no seu editor de texto preferido
e verifique que assim é: todo o texto que se encontra dentro do ambiente
\begin{quote}\small\tt
\text{\ttfamily \char92{}begin\char123{}code\char125{}}
\\ ... \\
\text{\ttfamily \char92{}end\char123{}code\char125{}}
\end{quote}
vai ser seleccionado pelo \GHCi\ para ser executado.

\section{Como realizar o trabalho}
Este trabalho teórico-prático deve ser realizado por grupos de três alunos.
Os detalhes da avaliação (datas para submissão do relatório e sua defesa
oral) são os que forem publicados na \cp{página da disciplina} na \emph{internet}.

Recomenda-se uma abordagem participativa dos membros do grupo
de trabalho por forma a poderem responder às questões que serão colocadas
na \emph{defesa oral} do relatório.

Em que consiste, então, o \emph{relatório} a que se refere o parágrafo anterior?
É a edição do texto que está a ser lido, preenchendo o anexo \ref{sec:resolucao}
com as respostas. O relatório deverá conter ainda a identificação dos membros
do grupo de trabalho, no local respectivo da folha de rosto.

Para gerar o PDF integral do relatório deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com \Bibtex) e o índice remissivo (com \Makeindex),
\begin{Verbatim}[fontsize=\small]
    $ bibtex cp1718t.aux
    $ makeindex cp1718t.idx
\end{Verbatim}
e recompilar o texto como acima se indicou. Dever-se-á ainda instalar o utilitário
\QuickCheck,
que ajuda a validar programas em \Haskell, a biblioteca
\href{https://hackage.haskell.org/package/JuicyPixels}{JuicyPixels} para processamento
de imagens e a biblioteca \href{http://gloss.ouroborus.net/}{gloss} para geração de gráficos 2D:
\begin{Verbatim}[fontsize=\small]
    $ cabal install QuickCheck JuicyPixels gloss
\end{Verbatim}
Para testar uma propriedade \QuickCheck~\ensuremath{\Varid{prop}}, basta invocá-la com o comando:
\begin{tabbing}\ttfamily
~~~~~\char62{}~quickCheck~prop\\
\ttfamily ~~~~~\char43{}\char43{}\char43{}~OK\char44{}~passed~100~tests\char46{}
\end{tabbing}

\section*{Problema 1}

Segundo uma \href{https://www.jn.pt/economia/interior/compra-diaria-de-bitcoins-iguala-acoes-da-apple-9257302.html}{notícia do Jornal de Notícias},
referente ao dia 12 de abril, \emph{``apenas numa hora, foram transacionadas 1.2 mil milhões de dólares em bitcoins. Nas últimas 24 horas, foram transacionados 8,5 mil milhões de dólares, num total de 24 mil milhões de dólares referentes às principais criptomoedas''}.

De facto, é inquestionável que as criptomoedas, e em particular as bitcoin, vieram para ficar.
%
Várias moedas digitais, e em particular as bitcoin, usam a tecnologia de block chain
para guardar e assegurar todas as transações relacionadas com a moeda.
%
Uma \href{https://en.bitcoin.it/wiki/Block_chain}{block chain} é uma coleção de blocos que registam os movimentos da moeda; a sua definição em Haskell é apresentada de seguida.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}c<{\hspost}@{}}%
\column{37E}{@{}l@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Blockchain}\mathrel{=}\Conid{Bc}\;\{\mskip1.5mu \Varid{bc}\mathbin{::}\Conid{Block}\mskip1.5mu\}{}\<[37]%
\>[37]{}\mid {}\<[37E]%
\>[40]{}\Conid{Bcs}\;\{\mskip1.5mu \Varid{bcs}\mathbin{::}(\Conid{Block},\Conid{Blockchain})\mskip1.5mu\}\;\mathbf{deriving}\;\Conid{Show}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Cada \href{https://en.bitcoin.it/wiki/Block}{bloco} numa block chain
regista um número (mágico) único, o momento da execução, e uma lista de transações,
tal como no código seguinte:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Block}\mathrel{=}(\Conid{MagicNo},(\Conid{Time},\Conid{Transactions})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Cada \href{https://en.bitcoin.it/wiki/Transaction}{transação}
define a entidade de origem da transferência, o valor a ser transacionado,
e a entidade destino (por esta ordem), tal como se define de seguida.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Transaction}\mathrel{=}(\Conid{Entity},(\Conid{Value},\Conid{Entity})){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Transactions}\mathrel{=}[\mskip1.5mu \Conid{Transaction}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A partir de uma block chain, é possível calcular o valor que cada entidade
detém, tipicamente designado de ledger:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Ledger}\mathrel{=}[\mskip1.5mu (\Conid{Entity},\Conid{Value})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Seguem as restantes definições Haskell para completar o código anterior.
Note que \ensuremath{\Conid{Time}} representa o momento da transação, como o número de \href{https://currentmillis.com}{milisegundos} que passaram desde 1970.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{MagicNo}\mathrel{=}\Conid{String}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Time}\mathrel{=}\Conid{Int}{}\<[18]%
\>[18]{}\mbox{\onelinecomment  em milisegundos}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Entity}\mathrel{=}\Conid{String}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Value}\mathrel{=}\Conid{Int}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Neste contexto, implemente as seguintes funções:

\begin{enumerate}
\item Defina a função \ensuremath{\Varid{allTransactions}\mathbin{::}\Conid{Blockchain}\to \Conid{Transactions}}, como um catamorfismo, que calcula a lista com todas as transações numa dada block chain.


\begin{propriedade}
    As transações de uma block chain são as mesmas da block chain revertida:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop1a}\mathrel{=}\Varid{sort}\comp \Varid{allTransactions}\equiv\Varid{sort}\comp \Varid{allTransactions}\comp \Varid{reverseChain}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note que a função \ensuremath{\Varid{sort}} é usada apenas para facilitar a comparação das listas.
\end{propriedade}

\item Defina a função \ensuremath{\Varid{ledger}\mathbin{::}\Conid{Blockchain}\to \Conid{Ledger}}, utilizando catamorfismos e/ou anamorfismos, que calcula o ledger (i.e., o valor disponível) de cada entidade numa uma dada block chain.
    Note que as entidades podem ter valores negativos; de facto isso acontecerá para a primeira transação que executarem.


\begin{propriedade}
    O tamanho do ledger é inferior ou igual a duas vezes o tamanho de todas as transações:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop1b}\mathrel{=}\length \comp \Varid{ledger}\leq(\mathrm{2}\mathbin{*})\comp \length \comp \Varid{allTransactions}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

\begin{propriedade}
    O ledger de uma block chain é igual ao ledger da sua inversa:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop1c}\mathrel{=}\Varid{sort}\comp \Varid{ledger}\equiv\Varid{sort}\comp \Varid{ledger}\comp \Varid{reverseChain}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}



\item Defina a função \ensuremath{\Varid{isValidMagicNr}\mathbin{::}\Conid{Blockchain}\to \Conid{Bool}}, utilizando catamorfismos e/ou anamorfismos, que verifica se todos os números mágicos numa dada block chain são únicos.


\begin{propriedade}
    A concatenação de uma block chain com ela mesma nunca é válida em termos de números mágicos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop1d}\mathrel{=}\neg \comp \Varid{isValidMagicNr}\comp \Varid{concChain}\comp \conj{\Varid{id}}{\Varid{id}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

\begin{propriedade}
    Se uma block chain é válida em termos de números mágicos, então a sua inversa também o é:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop1e}\mathrel{=}\Varid{isValidMagicNr}\Rightarrow\Varid{isValidMagicNr}\comp \Varid{reverseChain}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

\end{enumerate}



\section*{Problema 2}

Uma estrutura de dados frequentemente utilizada para representação e processamento de imagens de forma eficiente são as denominadas \href{https://en.wikipedia.org/wiki/Quadtree}{quadtrees}.
Uma \emph{quadtree} é uma árvore quaternária em que cada nodo tem quatro sub-árvores e cada folha representa um valor bi-dimensional.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{QTree}\;\Varid{a}\mathrel{=}\Conid{Cell}\;\Varid{a}\;\Conid{Int}\;\Conid{Int}\mid \Conid{Block}\;(\Conid{QTree}\;\Varid{a})\;(\Conid{QTree}\;\Varid{a})\;(\Conid{QTree}\;\Varid{a})\;(\Conid{QTree}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{deriving}\;(\Conid{Eq},\Conid{Show}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{figure}
\begin{subfigure}{0.3\textwidth}
\begin{tabbing}\ttfamily
~\char40{}~0~0~0~0~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~1~1~1~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~1~1~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~1~1~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~1~1~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~0~0~0~1~\char41{}
\end{tabbing}
\caption{Matriz de exemplo \ensuremath{\Varid{bm}}.}
\label{fig:bm}
\end{subfigure}
\begin{subfigure}{0.7\textwidth}
\begin{tabbing}\ttfamily
~Block\\
\ttfamily ~~\char40{}Cell~0~4~4\char41{}~\char40{}Block\\
\ttfamily ~~~\char40{}Cell~0~2~2\char41{}~\char40{}Cell~0~2~2\char41{}~\char40{}Cell~1~2~2\char41{}~\char40{}Block\\
\ttfamily ~~~~\char40{}Cell~1~1~1\char41{}~\char40{}Cell~0~1~1\char41{}~\char40{}Cell~0~1~1\char41{}~\char40{}Cell~0~1~1\char41{}\char41{}\char41{}\\
\ttfamily ~~\char40{}Cell~1~4~4\char41{}\\
\ttfamily ~~\char40{}Block\\
\ttfamily ~~~\char40{}Cell~1~2~2\char41{}~\char40{}Cell~0~2~2\char41{}~\char40{}Cell~0~2~2\char41{}~\char40{}Block\\
\ttfamily ~~~~\char40{}Cell~0~1~1\char41{}~\char40{}Cell~0~1~1\char41{}~\char40{}Cell~0~1~1\char41{}~\char40{}Cell~1~1~1\char41{}\char41{}\char41{}
\end{tabbing}
\caption{Quadtree de exemplo \ensuremath{\Varid{qt}}.}
\label{fig:qt}
\end{subfigure}
\caption{Exemplos de representações de bitmaps.}
\end{figure}

Uma imagem monocromática em formato bitmap pode ser representada como uma
matriz de bits\footnote{Cf.\ módulo \href{https://hackage.haskell.org/package/matrix}{\ensuremath{\Conid{\Conid{Data}.Matrix}}}.},
tal como se exemplifica na Figura~\ref{fig:bm}.

O anamorfismo \ensuremath{\Varid{bm2qt}} converte um bitmap em forma matricial na sua codificação eficiente em quadtrees, e o catamorfismo \ensuremath{\Varid{qt2bm}} executa a operação inversa:

\adjustbox{valign=t}{\begin{minipage}{.5\textwidth} %
\begingroup
\leftskip-1.5em
\rightskip\leftskip
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bm2qt}\mathbin{::}(\Conid{Eq}\;\Varid{a})\Rightarrow \Conid{Matrix}\;\Varid{a}\to \Conid{QTree}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{bm2qt}\mathrel{=}\Varid{anaQTree}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{f}\;\Varid{m}\mathrel{=}\mathbf{if}\;\Varid{one}\;\mathbf{then}\;i_1\;\Varid{u}\;\mathbf{else}\;i_2\;(\Varid{a},(\Varid{b},(\Varid{c},\Varid{d}))){}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\mathbf{where}\;{}\<[13]%
\>[13]{}\Varid{x}\mathrel{=}(\Varid{nub}\comp \Varid{toList})\;\Varid{m}{}\<[E]%
\\
\>[13]{}\Varid{u}\mathrel{=}(\Varid{head}\;\Varid{x},(\Varid{ncols}\;\Varid{m},\Varid{nrows}\;\Varid{m})){}\<[E]%
\\
\>[13]{}\Varid{one}\mathrel{=}(\Varid{ncols}\;\Varid{m}\equiv \mathrm{1}\mathrel{\vee}\Varid{nrows}\;\Varid{m}\equiv \mathrm{1}\mathrel{\vee}\length \;\Varid{x}\equiv \mathrm{1}){}\<[E]%
\\
\>[13]{}(\Varid{a},\Varid{b},\Varid{c},\Varid{d})\mathrel{=}\Varid{splitBlocks}\;(\Varid{nrows}\;\Varid{m}\mathbin{\Varid{`div`}}\mathrm{2})\;(\Varid{ncols}\;\Varid{m}\mathbin{\Varid{`div`}}\mathrm{2})\;\Varid{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\endgroup
\end{minipage}} %
\adjustbox{valign=t}{\begin{minipage}{.5\textwidth} %
\begingroup
\leftskip-2em
\rightskip\leftskip
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{qt2bm}\mathbin{::}(\Conid{Eq}\;\Varid{a})\Rightarrow \Conid{QTree}\;\Varid{a}\to \Conid{Matrix}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{qt2bm}\mathrel{=}\Varid{cataQTree}\;\alt{\Varid{f}}{\Varid{g}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{f}\;(\Varid{k},(\Varid{i},\Varid{j}))\mathrel{=}matrix\;\Varid{j}\;\Varid{i}\;\underline{\Varid{k}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{g}\;(\Varid{a},(\Varid{b},(\Varid{c},\Varid{d})))\mathrel{=}(\Varid{a}{\,\updownarrow\,}\Varid{b}){\,\leftrightarrow\,}(\Varid{c}{\,\updownarrow\,}\Varid{d}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\endgroup
\end{minipage}}

O algoritmo \ensuremath{\Varid{bm2qt}} particiona recursivamente a imagem em $4$ blocos e termina produzindo folhas para matrizes unitárias ou quando todos os píxeis de um sub-bloco têm a mesma côr.
Para a matriz \ensuremath{\Varid{bm}} de exemplo, a quadtree correspondente \ensuremath{\Varid{qt}\mathrel{=}\Varid{bm2qt}\;\Varid{bm}} é ilustrada na Figura~\ref{fig:qt}.

\begin{figure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/person.png}
\caption{Bitmap de exemplo.}
\label{fig:person}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[height=0.2\linewidth]{cp1718t_media/person90.png}
\caption{Rotação.}
\label{fig:person90}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.4\linewidth]{cp1718t_media/personx2.png}
\caption{Redimensionamento.}
\label{fig:personx2}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/personinv.png}
\caption{Inversão de cores.}
\label{fig:personinv}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/person1.png}
\caption{Compresão de $1$ nível.}
\label{fig:person1}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/person2.png}
\caption{Compresão de $2$ níveis.}
\label{fig:person2}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/person3.png}
\caption{Compresão de $3$ níveis.}
\label{fig:person3}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/person4.png}
\caption{Compresão de $4$ níveis.}
\label{fig:person4}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/personOut1.png}
\caption{Bitmap de contorno.}
\label{fig:personOut1}
\end{subfigure}
%
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.2\linewidth]{cp1718t_media/personOut2.png}
\caption{Bitmap com contorno.}
\label{fig:personOut2}
\end{subfigure}
%
\caption{Manipulação de uma figura bitmap utilizando quadtrees.}
\end{figure}

Imagens a cores podem ser representadas como matrizes de píxeis segundo o código de cores \href{https://en.wikipedia.org/wiki/RGBA_color_space}{RGBA}, codificado no tipo \href{https://hackage.haskell.org/package/JuicyPixels-3.2.9.5/docs/Codec-Picture.html#t:PixelRGBA8}{\ensuremath{\Conid{PixelRGBA8}}} em que cada pixel é um quádruplo de valores inteiros $(red,green,blue,alpha)$ contidos entre $0$ e $255$.
Atente em alguns exemplos de cores:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{whitePx}{}\<[10]%
\>[10]{}\mathrel{=}\Conid{PixelRGBA8}\;\mathrm{255}\;\mathrm{255}\;\mathrm{255}\;\mathrm{255}{}\<[E]%
\\
\>[B]{}\Varid{blackPx}{}\<[10]%
\>[10]{}\mathrel{=}\Conid{PixelRGBA8}\;\mathrm{0}\;\mathrm{0}\;\mathrm{0}\;\mathrm{255}{}\<[E]%
\\
\>[B]{}\Varid{redPx}{}\<[10]%
\>[10]{}\mathrel{=}\Conid{PixelRGBA8}\;\mathrm{255}\;\mathrm{0}\;\mathrm{0}\;\mathrm{255}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O módulo \ensuremath{\Conid{BMP}}, disponibilizado juntamente com o enunciado, fornece funções para processar ficheiros de imagem bitmap como matrizes:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{readBMP}\mathbin{::}\Conid{FilePath}\to \fun{IO}\;(\Conid{Matrix}\;\Conid{PixelRGBA8}){}\<[E]%
\\
\>[5]{}\Varid{writeBMP}\mathbin{::}\Conid{FilePath}\to \Conid{Matrix}\;\Conid{PixelRGBA8}\to \fun{IO}\;(){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Teste, por exemplo, no \ensuremath{\Conid{GHCi}}, carregar a Figura~\ref{fig:person}:
\begin{tabbing}\ttfamily
~~~~~\char62{}~readBMP~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}
\end{tabbing}

Esta questão aborda operações de processamento de imagens utilizando quadtrees:
\begin{enumerate}
    \item Defina as funções \ensuremath{\Varid{rotateQTree}\mathbin{::}\Conid{QTree}\;\Varid{a}\to \Conid{QTree}\;\Varid{a}}, \ensuremath{\Varid{scaleQTree}\mathbin{::}\Conid{Int}\to \Conid{QTree}\;\Varid{a}\to \Conid{QTree}\;\Varid{a}} e \ensuremath{\Varid{invertQTree}\mathbin{::}\Conid{QTree}\;\Varid{a}\to \Conid{QTree}\;\Varid{a}}, como catamorfismos e/ou anamorfismos, que rodam\footnote{Segundo um ângulo de $90º$ no sentido dos ponteiros do relógio.}, redimensionam \footnote{Multiplicando o seu tamanho pelo valor recebido.} e invertem as cores de uma quadtree\footnote{Um pixel pode ser invertido calculando $255 - c$ para cada componente $c$ de cor RGB, exceptuando o componente alpha.}, respectivamente.
    Tente produzir imagens similares às Figuras~\ref{fig:person90}, \ref{fig:personx2} e \ref{fig:personinv}:
        \begin{tabbing}\ttfamily
~~~~~\char62{}~rotateBMP~~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}person90\char46{}bmp\char34{}\\
\ttfamily ~~~~~\char62{}~scaleBMP~2~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}personx2\char46{}bmp\char34{}\\
\ttfamily ~~~~~\char62{}~invertBMP~~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}personinv\char46{}bmp\char34{}
\end{tabbing}

\begin{propriedade}
        Rodar uma quadtree é equivalente a rodar a matriz correspondente:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop2c}\mathrel{=}\Varid{rotateMatrix}\comp \Varid{qt2bm}\equiv\Varid{qt2bm}\comp \Varid{rotateQTree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \end{propriedade}
\begin{propriedade}
    Redimensionar uma imagem altera o seu tamanho na mesma proporção:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop2d}\;(\Conid{Nat}\;\Varid{s})\mathrel{=}\Varid{sizeQTree}\comp \Varid{scaleQTree}\;\Varid{s}\equiv((\Varid{s}\mathbin{*})\times(\Varid{s}\mathbin{*}))\comp \Varid{sizeQTree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}
\begin{propriedade}
    Inverter as cores de uma quadtree preserva a sua estrutura:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop2e}\mathrel{=}\Varid{shapeQTree}\comp \Varid{invertQTree}\equiv\Varid{shapeQTree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

    \item Defina a função \ensuremath{\Varid{compressQTree}\mathbin{::}\Conid{Int}\to \Conid{QTree}\;\Varid{a}\to \Conid{QTree}\;\Varid{a}}, utilizando catamorfismos e/ou anamorfismos, que comprime uma quadtree cortando folhas da árvore para reduzir a sua profundidade num dado número de níveis.
    Tente produzir imagens similares (mas não necessariamente iguais) às Figuras~\ref{fig:person1}, \ref{fig:person2}, \ref{fig:person3} e \ref{fig:person4}:
        \begin{tabbing}\ttfamily
~~~~~\char62{}~compressBMP~1~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}person1\char46{}bmp\char34{}\\
\ttfamily ~~~~~\char62{}~compressBMP~2~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}person2\char46{}bmp\char34{}\\
\ttfamily ~~~~~\char62{}~compressBMP~3~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}person3\char46{}bmp\char34{}\\
\ttfamily ~~~~~\char62{}~compressBMP~4~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}person4\char46{}bmp\char34{}
\end{tabbing}
    \begin{propriedade}
        A quadtree comprimida tem profundidade igual à da quadtree original menos a taxa de compressão:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop2f}\;(\Conid{Nat}\;\Varid{n})\mathrel{=}\Varid{depthQTree}\comp \Varid{compressQTree}\;\Varid{n}\equiv(\mathbin{-}\Varid{n})\comp \Varid{depthQTree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \end{propriedade}


    \item Defina a função \ensuremath{\Varid{outlineQTree}\mathbin{::}(\Varid{a}\to \Conid{Bool})\to \Conid{QTree}\;\Varid{a}\to \Conid{Matrix}\;\Conid{Bool}}, utilizando catamorfismos e/ou anamorfismos, que recebe uma função que determina quais os píxeis de fundo e converte uma quadtree numa matriz monocromática, de forma a desenhar o contorno de uma \href{https://en.wikipedia.org/wiki/Polygon_mesh}{malha poligonal} contida na imagem.
        Tente produzir imagens similares (mas não necessariamente iguais) às Figuras~\ref{fig:personOut1} e \ref{fig:personOut2}:
            \begin{tabbing}\ttfamily
~~~~~\char62{}~outlineBMP~~~~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}personOut1\char46{}bmp\char34{}\\
\ttfamily ~~~~~\char62{}~addOutlineBMP~\char34{}cp1718t\char95{}media\char47{}person\char46{}bmp\char34{}~\char34{}personOut2\char46{}bmp\char34{}
\end{tabbing}
    \begin{propriedade}
        A matriz de contorno tem dimensões iguais às da quadtree:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop2g}\mathrel{=}\Varid{sizeQTree}\equiv\Varid{sizeMatrix}\comp \Varid{outlineQTree}\;(\mathbin{<}\mathrm{0}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \end{propriedade}
    \begin{teste}
        Contorno da quadtree de exemplo \ensuremath{\Varid{qt}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{teste2a}\mathrel{=}\Varid{outlineQTree}\;(\equiv \mathrm{0})\;\Varid{qt}\equiv \Varid{qtOut}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \end{teste}

\end{enumerate}

\section*{Problema 3}
O cálculo das combinações de \ensuremath{\Varid{n}} \ensuremath{\Varid{k}}-a-\ensuremath{\Varid{k}},
\begin{eqnarray}
	\ensuremath{\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\mathrel{=}\frac{{\Varid{n}!}}{{\Varid{k}!}\mathbin{*}{(\Varid{n}\mathbin{-}\Varid{k})!}}}
	\label{eq:bin}
\end{eqnarray}
envolve três factoriais. Recorrendo à \material{lei de recursividade múltipla} do cálculo
de programas, é possível escrever o mesmo programa como um simples ciclo-for
onde se fazem apenas multiplicações e somas. Para isso, começa-se por estruturar
a definição dada da forma seguinte,
\begin{eqnarray*}
	\ensuremath{\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\mathrel{=}\Varid{h}\;\Varid{k}\;(\Varid{n}\mathbin{-}\Varid{k})}
\end{eqnarray*}
onde
\begin{eqnarray*}
\start
       \ensuremath{\Varid{h}\;\Varid{k}\;\Varid{d}\mathrel{=}\frac{\Varid{f}\;\Varid{k}\;\Varid{d}}{\Varid{g}\;\Varid{d}}}
\more
       \ensuremath{\Varid{f}\;\Varid{k}\;\Varid{d}\mathrel{=}\frac{{(\Varid{d}\mathbin{+}\Varid{k})!}}{{\Varid{k}!}}}
\more
       \ensuremath{\Varid{g}\;\Varid{d}\mathrel{=}{\Varid{d}!}}
\end{eqnarray*}
assumindo-se \ensuremath{\Varid{d}\mathrel{=}\Varid{n}\mathbin{-}\Varid{k}\geq \mathrm{0}}.
%
É fácil de ver que \ensuremath{\Varid{f}\;\Varid{k}} e \ensuremath{\Varid{g}} se desdobram em 4 funções mutuamente recursivas, a saber
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\;\Varid{k}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{f}\;\Varid{k}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\underbrace{(\Varid{d}\mathbin{+}\Varid{k}\mathbin{+}\mathrm{1})}_{\Varid{l}\;\Varid{k}\;\Varid{d}}\mathbin{*}\Varid{f}\;\Varid{k}\;\Varid{d}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{l}\;\Varid{k}\;\mathrm{0}\mathrel{=}\Varid{k}\mathbin{+}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{l}\;\Varid{k}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{l}\;\Varid{k}\;\Varid{d}\mathbin{+}\mathrm{1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
e
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{g}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{g}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\underbrace{(\Varid{d}\mathbin{+}\mathrm{1})}_{\Varid{s}\;\Varid{d}}\mathbin{*}\Varid{g}\;\Varid{d}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{s}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{s}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{s}\;\Varid{d}\mathbin{+}\mathrm{1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A partir daqui alguém derivou a seguinte implementação:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\mathrel{=}\Varid{h}\;\Varid{k}\;(\Varid{n}\mathbin{-}\Varid{k})\;\mathbf{where}\;{}\<[28]%
\>[28]{}\Varid{h}\;\Varid{k}\;\Varid{n}\mathrel{=}\mathbf{let}\;(\Varid{a},\anonymous ,\Varid{b},\anonymous )\mathrel{=}\mathsf{for}\ \Varid{loop}\ (\Varid{base}\;\Varid{k})\;\Varid{n}\;\mathbf{in}\;\Varid{a}\mathbin{/}\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Aplicando a lei da recursividade múltipla para \ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}} e para
\ensuremath{\conj{\Varid{g}}{\Varid{s}}} e combinando os resultados com a \material{lei de banana-split},
derive as funções \ensuremath{\Varid{base}\;\Varid{k}} e \ensuremath{\Varid{loop}} que são usadas como auxiliares acima.

\begin{propriedade}
Verificação que \ensuremath{\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)} coincide com a sua especificação (\ref{eq:bin}):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop3}\;(\Conid{NonNegative}\;\Varid{n})\;(\Conid{NonNegative}\;\Varid{k})\mathrel{=}\Varid{k}\leq \Varid{n}\Rightarrow\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\equiv {\Varid{n}!}\mathbin{/}({\Varid{k}!}\mathbin{*}{(\Varid{n}\mathbin{-}\Varid{k})!}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

\section*{Problema 4}

\begin{figure}
\begin{center}
\includegraphics[width=0.7\textwidth]{cp1718t_media/pythagoras-tree1.png}
\end{center}
\caption{Passos de construção de uma árvore de Pitágoras de ordem $3$.}
\label{fig:pitagoras1}
\end{figure}

\href{https://en.wikipedia.org/wiki/Fractal}{Fractais} são formas geométricas que podem ser construídas recursivamente de acordo com um conjunto de equações matemáticas.
Um exemplo clássico de um fractal são as \href{https://en.wikipedia.org/wiki/Pythagoras_tree_(fractal)}{árvores de Pitágoras}.
A construção de uma árvore de Pitágoras começa com um quadrado, ao qual se unem dois quadrados redimensionados pela escala $\sqrt{2}/2$, de forma a que os cantos dos $3$ quadrados coincidam e formem um triângulo rectângulo isósceles.
Este procedimento é repetido recursivamente de acordo com uma dada ordem, definida como um número natural (Figura~\ref{fig:pitagoras1}).

Uma árvore de Pitágoras pode ser codificada em Haskell como uma full tree contendo quadrados nos nodos e nas folhas, sendo um quadrado definido simplesmente pelo tamanho do seu lado:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{FTree}\;\Varid{a}\;\Varid{b}\mathrel{=}\Conid{Unit}\;\Varid{b}\mid \Conid{Comp}\;\Varid{a}\;(\Conid{FTree}\;\Varid{a}\;\Varid{b})\;(\Conid{FTree}\;\Varid{a}\;\Varid{b})\;\mathbf{deriving}\;(\Conid{Eq},\Conid{Show}){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{PTree}\mathrel{=}\Conid{FTree}\;\Conid{Square}\;\Conid{Square}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Square}\mathrel{=}\Conid{Float}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{enumerate}
    \item Defina a função \ensuremath{\Varid{generatePTree}\mathbin{::}\Conid{Int}\to \Conid{PTree}}, como um anamorfismo, que gera uma árvore de Pitágoras para uma dada ordem.


\begin{propriedade}
    Uma árvore de Pitágoras tem profundidade igual à sua ordem:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop4a}\;(\Conid{SmallNat}\;\Varid{n})\mathrel{=}(\Varid{depthFTree}\comp \Varid{generatePTree})\;\Varid{n}\equiv \Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}
\begin{propriedade}
    Uma árvore de Pitágoras está sempre balanceada:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop4b}\;(\Conid{SmallNat}\;\Varid{n})\mathrel{=}(\Varid{isBalancedFTree}\comp \Varid{generatePTree})\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{propriedade}

\item Defina a função \ensuremath{\Varid{drawPTree}\mathbin{::}\Conid{PTree}\to [\mskip1.5mu \Conid{Picture}\mskip1.5mu]}, utilizando catamorfismos e/ou anamorfismos, que anima incrementalmente os passos de construção de uma árvore de Pitágoras recorrendo à biblioteca \href{https://hackage.haskell.org/package/gloss}{gloss}.
    Anime a sua solução:
\begin{tabbing}\ttfamily
~~~~~\char62{}~animatePTree~3
\end{tabbing}


\end{enumerate}

\section*{Problema 5}

Uma das áreas em maior expansão no campo da informática é a análise de dados
e  \href{https://www.mathworks.com/discovery/machine-learning.html}{machine learning}. Esta questão aborda um \emph{mónade} que ajuda
a fazer, de forma simples, as operações básicas dessas técnicas. Esse mónade
é conhecido por \emph{bag}, \emph{saco} ou \emph{multi-conjunto}, permitindo
que os elementos de um conjunto tenham multiplicidades associadas. Por exemplo,
seja
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Marble}\mathrel{=}\Conid{Red}\mid \Conid{Pink}\mid \Conid{Green}\mid \Conid{Blue}\mid \Conid{White}\;\mathbf{deriving}\;(\Conid{Read},\Conid{Show},\Conid{Eq},\Conid{Ord}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
um tipo dado.\footnote{``Marble" traduz para ``berlinde" em português.}
A lista \ensuremath{[\mskip1.5mu \Conid{Pink},\Conid{Green},\Conid{Red},\Conid{Blue},\Conid{Green},\Conid{Red},\Conid{Green},\Conid{Pink},\Conid{Blue},\Conid{White}\mskip1.5mu]} tem elementos
repetidos. Assumindo que a ordem não é importante, essa lista corresponde ao saco
\begin{quote}\small
\begin{tabbing}\ttfamily
~\char123{}~Red~\char124{}\char45{}\char62{}~2~\char44{}~Pink~\char124{}\char45{}\char62{}~2~\char44{}~Green~\char124{}\char45{}\char62{}~3~\char44{}~Blue~\char124{}\char45{}\char62{}~2~\char44{}~White~\char124{}\char45{}\char62{}~1~\char125{}
\end{tabbing}
\end{quote}
que habita o tipo genérico dos ``bags":
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Bag}\;\Varid{a}\mathrel{=}\Conid{B}\;[\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]\;\mathbf{deriving}\;(\Conid{Ord}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
O mónade que vamos construir sobre este tipo de dados faz a gestão automática das multiciplidades.
Por exemplo, seja dada a função que dá o peso de cada berlinde em gramas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{marbleWeight}\mathbin{::}\Conid{Marble}\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{marbleWeight}\;\Conid{Red}{}\<[20]%
\>[20]{}\mathrel{=}\mathrm{3}{}\<[E]%
\\
\>[B]{}\Varid{marbleWeight}\;\Conid{Pink}{}\<[20]%
\>[20]{}\mathrel{=}\mathrm{2}{}\<[E]%
\\
\>[B]{}\Varid{marbleWeight}\;\Conid{Green}\mathrel{=}\mathrm{3}{}\<[E]%
\\
\>[B]{}\Varid{marbleWeight}\;\Conid{Blue}{}\<[20]%
\>[20]{}\mathrel{=}\mathrm{6}{}\<[E]%
\\
\>[B]{}\Varid{marbleWeight}\;\Conid{White}\mathrel{=}\mathrm{2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Então, se quisermos saber quantos \emph{berlindes} temos, de cada \emph{peso}, não teremos que fazer contas:
basta calcular
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{marbleWeights}\mathrel{=}\mathsf{fmap}\;\Varid{marbleWeight}\;\Varid{bagOfMarbles}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
onde \ensuremath{\Varid{bagOfMarbles}} é o saco de berlindes referido acima, obtendo-se:
\begin{quote}\small
	\text{\ttfamily \char123{}~2~\char124{}\char45{}\char62{}~3~\char44{}~3~\char124{}\char45{}\char62{}~5~\char44{}~6~\char124{}\char45{}\char62{}~2~\char125{}}.
\end{quote}
%
Mais ainda, se quisermos saber o total de berlindes em \ensuremath{\Varid{bagOfMarbles}} basta
calcular \ensuremath{\mathsf{fmap}\;(\mathbin{!})\;\Varid{bagOfMarbles}} obtendo-se \text{\ttfamily \char123{}~\char40{}\char41{}~\char124{}\char45{}\char62{}~10~\char125{}}; isto é,
o saco tem \ensuremath{\mathrm{10}} berlindes no total.


Finalmente, se quisermos saber a probabilidade da cor de um berlinde que tiremos do saco, basta converter
o referido saco numa distribuição correndo:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{marblesDist}\mathrel{=}\Varid{dist}\;\Varid{bagOfMarbles}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
obtendo-se a distribuição (graças ao módulo \Probability):
\begin{quote}\small
\begin{tabbing}\ttfamily
~Green~~30\char46{}0\char37{}\\
\ttfamily ~~~Red~~20\char46{}0\char37{}\\
\ttfamily ~~Pink~~20\char46{}0\char37{}\\
\ttfamily ~~Blue~~20\char46{}0\char37{}\\
\ttfamily ~White~~10\char46{}0\char37{}
\end{tabbing}
\end{quote}
cf.\ Figura \ref{fig:dist}.

\begin{figure}
\begin{center}
\includegraphics[width=0.4\textwidth]{cp1718t_media/marblesDist-mod5.png}
\end{center}
\caption{Distribuição de berlindes num saco.}
\label{fig:dist}
\end{figure}

Partindo da seguinte declaração de \ensuremath{\Conid{Bag}} como um functor e como um mónade,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Functor}\;\Conid{Bag}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathsf{fmap}\;\Varid{f}\mathrel{=}\Conid{B}\comp \map \;(\Varid{f}\times\Varid{id})\comp \Varid{unB}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monad}\;\Conid{Bag}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{x}\bind \Varid{f}\mathrel{=}(\mu \comp \mathsf{fmap}\;\Varid{f})\;\Varid{x}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{return}\mathrel{=}\Varid{singletonbag}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\begin{enumerate}
\item
Defina a função \ensuremath{\mu } (multiplicação do mónade \ensuremath{\Conid{Bag}}) e a função auxiliar
\ensuremath{\Varid{singletonbag}}.
\item	Verifique-as com os seguintes testes unitários:
\begin{teste}
Lei \ensuremath{\mu \comp \Varid{return}\mathrel{=}\Varid{id}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{test5a}\mathrel{=}\Varid{bagOfMarbles}\equiv \mu \;(\Varid{return}\;\Varid{bagOfMarbles}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{teste}
\begin{teste}
Lei \ensuremath{\mu \comp \mu \mathrel{=}\mu \comp \mathsf{fmap}\;\mu }:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{test5b}\mathrel{=}(\mu \comp \mu )\;\Varid{b3}\equiv (\mu \comp \mathsf{fmap}\;\mu )\;\Varid{b3}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\vskip 1em
onde \ensuremath{\Varid{b3}} é um saco dado em anexo.
\end{teste}
\end{enumerate}

%----------------- Bibliografia (exige bibtex) --------------------------------%

\bibliographystyle{plain}
\bibliography{cp1718t}

%----------------- Programa, bibliotecas e código auxiliar --------------------%

\newpage

\part*{Anexos}

\appendix

\section{Mónade para probabilidades e estatística}\label{sec:Dist}
Mónades são functores com propriedades adicionais que nos permitem obter
efeitos especiais em progra\-mação. Por exemplo, a biblioteca \Probability\
oferece um mónade para abordar problemas de probabilidades. Nesta biblioteca,
o conceito de distribuição estatística é captado pelo tipo
\begin{eqnarray}
	\ensuremath{\mathbf{newtype}\;\fun{Dist}\;\Varid{a}\mathrel{=}\Conid{D}\;\{\mskip1.5mu \Varid{unD}\mathbin{::}[\mskip1.5mu (\Varid{a},\Conid{ProbRep})\mskip1.5mu]\mskip1.5mu\}}
	\label{eq:Dist}
\end{eqnarray}
em que \ensuremath{\Conid{ProbRep}} é um real de \ensuremath{\mathrm{0}} a \ensuremath{\mathrm{1}}, equivalente a uma escala de \ensuremath{\mathrm{0}} a \ensuremath{\mathrm{100}\mathbin{/}}.

Cada par \ensuremath{(\Varid{a},\Varid{p})} numa distribuição \ensuremath{\Varid{d}\mathbin{::}\fun{Dist}\;\Varid{a}} indica que a probabilidade
de \ensuremath{\Varid{a}} é \ensuremath{\Varid{p}}, devendo ser garantida a propriedade de  que todas as probabilidades
de \ensuremath{\Varid{d}} somam \ensuremath{\mathrm{100}\mathbin{/}}.
Por exemplo, a seguinte distribuição de classificações por escalões de $A$ a $E$,
\[
\begin{array}{ll}
A & \rule{2mm}{3pt}\ 2\%\\
B & \rule{12mm}{3pt}\ 12\%\\
C & \rule{29mm}{3pt}\ 29\%\\
D & \rule{35mm}{3pt}\ 35\%\\
E & \rule{22mm}{3pt}\ 22\%\\
\end{array}
\]
será representada pela distribuição
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{d1}\mathbin{::}\fun{Dist}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}\Varid{d1}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\text{\ttfamily 'A'},\mathrm{0.02}),(\text{\ttfamily 'B'},\mathrm{0.12}),(\text{\ttfamily 'C'},\mathrm{0.29}),(\text{\ttfamily 'D'},\mathrm{0.35}),(\text{\ttfamily 'E'},\mathrm{0.22})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que o \GHCi\ mostrará assim:
\begin{Verbatim}[fontsize=\small]
'D'  35.0%
'C'  29.0%
'E'  22.0%
'B'  12.0%
'A'   2.0%
\end{Verbatim}

Este mónade é adequado à resolução de problemas de \emph{probabilidades e
estatística} usando programação funcional, de forma elegante e como caso
particular de programação monádica.

\section{Definições auxiliares}\label{sec:helper_functions}
Funções para mostrar \emph{bags}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\Conid{Show}\;\Varid{a},\Conid{Ord}\;\Varid{a},\Conid{Eq}\;\Varid{a})\Rightarrow \Conid{Show}\;(\Conid{Bag}\;\Varid{a})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{show}\mathrel{=}\Varid{showbag}\comp \Varid{consol}\comp \Varid{unB}\;{}\<[36]%
\>[36]{}\mathbf{where}{}\<[E]%
\\
\>[5]{}\hsindent{3}{}\<[8]%
\>[8]{}\Varid{showbag}\mathrel{=}\Varid{concat}\comp {}\<[E]%
\\
\>[8]{}\hsindent{10}{}\<[18]%
\>[18]{}(\plus [\mskip1.5mu \text{\ttfamily \char34 ~\char125 \char34}\mskip1.5mu])\comp {}\<[33]%
\>[33]{}(\text{\ttfamily \char34 \char123 ~\char34}\mathbin{:})\comp {}\<[E]%
\\
\>[8]{}\hsindent{10}{}\<[18]%
\>[18]{}(\Varid{intersperse}\;\text{\ttfamily \char34 ~,~\char34})\comp {}\<[E]%
\\
\>[8]{}\hsindent{10}{}\<[18]%
\>[18]{}\Varid{sort}\comp {}\<[E]%
\\
\>[8]{}\hsindent{10}{}\<[18]%
\>[18]{}(\map \;\Varid{f})\;\mathbf{where}\;\Varid{f}\;(\Varid{a},\Varid{b})\mathrel{=}(\Varid{show}\;\Varid{a})\plus \text{\ttfamily \char34 ~|->~\char34}\plus (\Varid{show}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{unB}\;(\mathit B\;\Varid{x})\mathrel{=}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Igualdade de \emph{bags}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;(\Conid{Eq}\;\Varid{a})\Rightarrow \Conid{Eq}\;(\Conid{Bag}\;\Varid{a})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{b}\equiv \Varid{b'}\mathrel{=}(\Varid{unB}\;\Varid{b})\mathbin{`\Varid{lequal}`}(\Varid{unB}\;\Varid{b'}){}\<[E]%
\\
\>[4]{}\hsindent{8}{}\<[12]%
\>[12]{}\mathbf{where}\;\Varid{lequal}\;\Varid{a}\;\Varid{b}\mathrel{=}\Varid{isempty}\;(\Varid{a}\mathbin{\ominus}\Varid{b}){}\<[E]%
\\
\>[12]{}\hsindent{6}{}\<[18]%
\>[18]{}\Varid{ominus}\;\Varid{a}\;\Varid{b}\mathrel{=}\Varid{a}\plus \Varid{neg}\;\Varid{b}{}\<[E]%
\\
\>[12]{}\hsindent{6}{}\<[18]%
\>[18]{}\Varid{neg}\;\Varid{x}\mathrel{=}[\mskip1.5mu (\Varid{k},\mathbin{-}\Varid{i})\mid (\Varid{k},\Varid{i})\leftarrow \Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Ainda sobre o mónade \ensuremath{\Conid{Bag}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Applicative}\;\Conid{Bag}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{pure}\mathrel{=}\Varid{return}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\mathbin{<*>})\mathrel{=}\Varid{aap}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
O exemplo do texto:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{bagOfMarbles}\mathrel{=}\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{2}),(\Conid{Green},\mathrm{3}),(\Conid{Red},\mathrm{2}),(\Conid{Blue},\mathrm{2}),(\Conid{White},\mathrm{1})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Um valor para teste (bags de bags de bags):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{b3}\mathbin{::}\Conid{Bag}\;(\Conid{Bag}\;(\Conid{Bag}\;\Conid{Marble})){}\<[E]%
\\
\>[B]{}\Varid{b3}\mathrel{=}\mathit B\;[\mskip1.5mu (\mathit B\;[\mskip1.5mu (\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{2}),(\Conid{Green},\mathrm{3}),(\Conid{Red},\mathrm{2}),(\Conid{Blue},\mathrm{2}),(\Conid{White},\mathrm{1})\mskip1.5mu],\mathrm{5}){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{},(\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{1}),(\Conid{Green},\mathrm{2}),(\Conid{Red},\mathrm{1}),(\Conid{Blue},\mathrm{1})\mskip1.5mu],\mathrm{2})\mskip1.5mu],\mathrm{2})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Outras funções auxiliares:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{a}\mapsto\Varid{b}\mathrel{=}(\Varid{a},\Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{consol}\mathbin{::}(\Conid{Eq}\;\Varid{b})\Rightarrow [\mskip1.5mu (\Varid{b},\Conid{Int})\mskip1.5mu]\to [\mskip1.5mu (\Varid{b},\Conid{Int})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{consol}\mathrel{=}\Varid{filter}\;\Varid{nzero}\comp \map \;(\Varid{id}\times\Varid{sum})\comp \Varid{col}\;\mathbf{where}\;\Varid{nzero}\;(\anonymous ,\Varid{x})\mathrel{=}\Varid{x}\not\equiv \mathrm{0}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{isempty}\mathbin{::}\Conid{Eq}\;\Varid{a}\Rightarrow [\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{isempty}\mathrel{=}\Varid{all}\;(\equiv \mathrm{0})\comp \map \;\p2\comp \Varid{consol}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{col}\;\Varid{x}\mathrel{=}\Varid{nub}\;[\mskip1.5mu \Varid{k}\mapsto[\mskip1.5mu \Varid{d'}\mid (\Varid{k'},\Varid{d'})\leftarrow \Varid{x},\Varid{k'}\equiv \Varid{k}\mskip1.5mu]\mid (\Varid{k},\Varid{d})\leftarrow \Varid{x}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{consolidate}\mathbin{::}\Conid{Eq}\;\Varid{a}\Rightarrow \Conid{Bag}\;\Varid{a}\to \Conid{Bag}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{consolidate}\mathrel{=}\mathit B\comp \Varid{consol}\comp \Varid{unB}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Soluções dos alunos -----------------------------------------%

\section{Soluções dos alunos}\label{sec:resolucao}
Os alunos devem colocar neste anexo as suas soluções aos exercícios
propostos, de acordo com o ``layout'' que se fornece. Não podem ser
alterados os nomes ou tipos das funções dadas, mas pode ser adicionado texto e / ou
outras funções auxiliares que sejam necessárias.

\subsection*{Problema 1}

O primeiro problema tem como tema uma block chain, ou seja, uma coleção de blocos
que registam movimentos da moeda.

De modo a resolvê-lo, antes de procedermos ao desenvolvimento
das suas 3 alíneas, tivemos que definir algumas funções que nos ajudarão
a implementar as soluções requeridas.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inBlockchain}\mathrel{=}\alt{\Conid{Bc}}{\Conid{Bcs}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{outBlockchain}\;(\Conid{Bc}\;\Varid{a})\mathrel{=}i_1\;(\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{outBlockchain}\;(\Conid{Bcs}\;(\Varid{a},\Varid{b}))\mathrel{=}i_2\;(\Varid{a},\Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recBlockchain}\;\Varid{g}\mathrel{=}\Varid{id}+(\Varid{id}\times\Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cataBlockchain}\;\Varid{g}\mathrel{=}\Varid{g}\comp (\Varid{recBlockchain}\;(\Varid{cataBlockchain}\;\Varid{g}))\comp \Varid{outBlockchain}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{anaBlockchain}\;\Varid{g}\mathrel{=}\Varid{inBlockchain}\comp (\Varid{recBlockchain}\;(\Varid{anaBlockchain}\;\Varid{g}))\comp \Varid{g}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hyloBlockchain}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{cataBlockchain}\;\Varid{h}\comp \Varid{anaBlockchain}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Estas funções, nomeadamente \ensuremath{\Varid{inBlockchain}}, \ensuremath{\Varid{outBlockchain}},
\ensuremath{\Varid{recBlockchain}}, \ensuremath{\Varid{cataBlockchain}}, \ensuremath{\Varid{anaBlockchain}} e \ensuremath{\Varid{hyloBlockchain}}, podem ser
deduzidas tendo em consideração o Tipo de Dados do problema, a matéria de Cálculo
de Programas e com a ajuda de alguns diagramas.

\vspace{0.2cm}

Uma vez que o tipo de Blockchain é
\ensuremath{\Conid{Bc}\;\{\mskip1.5mu \Varid{bc}\mathbin{::}\Conid{Block}\mskip1.5mu\}}
ou
\ensuremath{\Conid{Bcs}\;\{\mskip1.5mu \Varid{bcs}\mathbin{::}(\Conid{Block},\Conid{Blockchain})\mskip1.5mu\}},
sabemos que o \ensuremath{\Varid{inBlockchain}} e o \ensuremath{\Varid{outBlockchain}} deverão "fechar" e "abrir"
a Blockchain, respetivamente, logo, conseguimos representar os diagramas:
\begin{eqnarray*}
\xymatrix@C=2cm{
     \ensuremath{\Conid{Blockchain}}
&
     \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Blockchain})}
           \ar[l]^-{\ensuremath{\Varid{inBlockchain}}}
}
\end{eqnarray*}

\begin{eqnarray*}
\xymatrix@C=2cm{
     \ensuremath{\Conid{Blockchain}}
           \ar[r]_-{\ensuremath{\Varid{outBlockchain}}}
&
     \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Blockchain})}
}
\end{eqnarray*}

Assim, conseguimos perceber de imediato a definição de ambas as funções:
\begin{eqnarray*}
\start
\ensuremath{\Varid{inBlockchain}\mathrel{=}\alt{\Conid{Bc}}{\Conid{Bcs}}}
\end{eqnarray*}
\begin{eqnarray*}
\start
\ensuremath{\Varid{outBlockchain}\;(\Conid{Bc}\;\Varid{a})\mathrel{=}i_1\;(\Varid{a})}
\more
\ensuremath{\Varid{outBlockchain}\;(\Conid{Bcs}\;(\Varid{a},\Varid{b}))\mathrel{=}i_2\;(\Varid{a},\Varid{b})}
\end{eqnarray*}

Relativamente às funções \ensuremath{\Varid{recBlockchain}}, \ensuremath{\Varid{cataBlockchain}},
\ensuremath{\Varid{anaBlockchain}} e \ensuremath{\Varid{hyloBlockchain}}, os seus tipos já estavam presentes
no enunciado e o significado e intuito de cada uma delas também já era sabido.

A título de exemplo, através do diagrama em seguida conseguimos ter uma
melhor perceção de qual deverá ser a definição de cada uma destas funções.

Assumimos que as funções \ensuremath{\Varid{g}} e \ensuremath{\Varid{h}} mencionadas são funções que devolvem
a identidade.


\begin{eqnarray*}
\xymatrix@C=3cm{
   \ensuremath{\Conid{Blockchain}}
          \ar[d]_-{\ensuremath{\Varid{anaBlockchain}\;\Varid{g}}}
           \ar[r]^-{\ensuremath{\Varid{g}}}
&
   \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Blockchain})}
          \ar[d]^{\ensuremath{\Varid{recBlockchain}\;(\Varid{anaBlockchain}\;\Varid{g})}}
\\
    \ensuremath{\Conid{Blockchain}}
       \ar[d]_-{\ensuremath{\Varid{cataBlockchain}\;\Varid{h}}}
       \ar[r]^-{\ensuremath{\Varid{outBlockchain}}}
&
    \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Blockchain})}
          \ar[l]^-{\ensuremath{\Varid{inBlockchain}}}
           \ar[d]^{\ensuremath{\Varid{recBlockchain}\;(\Varid{cataBlockchain}\;\Varid{h})}}
\\
   \ensuremath{\Conid{Blockchain}}
&
   \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Blockchain})}
       \ar[l]^-{\ensuremath{\Varid{h}}}
}
\end{eqnarray*}

Assim, intuitivamente conseguimos perceber a definição de cada uma delas.
\begin{eqnarray*}
\start
\ensuremath{\Varid{recBlockchain}\;\Varid{g}\mathrel{=}\Varid{id}\mathbin{+}(\Varid{id}\times\Varid{g})}
\more
\ensuremath{\Varid{cataBlockchain}\;\Varid{h}\mathrel{=}\Varid{h}\comp (\Varid{recBlockchain}\;(\Varid{cataBlockchain}\;\Varid{h}))\comp \Varid{outBlockchain}}
\more
\ensuremath{\Varid{anaBlockchain}\;\Varid{g}\mathrel{=}\Varid{inBlockchain}\comp (\Varid{recBlockchain}\;(\Varid{anaBlockchain}\;\Varid{g}))\comp \Varid{g}}
\more
\ensuremath{\Varid{hyloBlockchain}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{cataBlockchain}\;\Varid{h}\comp \Varid{anaBlockchain}\;\Varid{g}}
\end{eqnarray*}


Na resolução das alíneas recorremos a alguns diagramas onde também fica
implícito o porquê da definição de cada uma destas funções.


\begin{enumerate}
\item Função \ensuremath{\Varid{allTransactions}}

O objetivo da função \ensuremath{\Varid{allTransactions}} é calcular a lista com todas as transações
numa dada block chain, utilizando um catamorfismo.

O diagrama desta função será:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\Conid{Blockchain}}
           \ar[d]_-{\ensuremath{\Varid{cataBlockchain}\;\Varid{g}}}
&
    \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Blockchain})}
           \ar[d]^{\ensuremath{\Varid{recBlockchain}\;(\Varid{cataBlockchain}\;\Varid{g})}}
           \ar[l]_-{\ensuremath{\Varid{inBlockchain}}}
\\
     \ensuremath{\Conid{Transactions}}
&
     \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Transactions})}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}


O objetivo é descobrir o gene \ensuremath{\Varid{g}}, para assim termos a definição final de como
algo do género \ensuremath{\Varid{allTransactions}\mathrel{=}\Varid{cataBlockchain}\;\Varid{g}}

Assim, tendo em atenção o tipo de Block:
\begin{eqnarray*}
\ensuremath{\mathbf{type}\;\Conid{Block}\mathrel{=}(\Conid{MagicNo},(\Conid{Time},\Conid{Transactions}))}
\end{eqnarray*}

E o tipo de Blockchain já apresentado, deduzimos que o \ensuremath{\Varid{g}} terá que ser um ``either'',
\ensuremath{\Varid{g}\mathrel{=}\alt{\Varid{b0}}{\Varid{joint}}},
onde de um lado irá tratar o \ensuremath{\Conid{Block}} e do outro o \ensuremath{\Conid{Block}\times\Conid{Transactions}}. Isso deve-se
ao facto de \ensuremath{\Varid{g}} receber como parâmetro: \ensuremath{\Conid{Block}\mathbin{+}(\Conid{Block}\times\Conid{Transactions})}, ou seja, uma
"soma", e devolver: \ensuremath{\Conid{Transactions}}, logo, obrigatoriamente a função terá que ser ``either''
para abolir o \ensuremath{\mathbin{+}}.


\begin{enumerate}
\item Descobrir \ensuremath{\Varid{b0}}

Para tratar o lado em que o domínio é \ensuremath{\Conid{Block}}, e sabendo que o resultado terá que
ser \ensuremath{\Conid{Transactions}}, o objetivo desta função será "retirar" do \ensuremath{\Conid{Block}} as \ensuremath{\Conid{Transactions}}.

Assim, teremos que definir \ensuremath{\Varid{b0}} com projeções \ensuremath{\p2} como podemos verificar no diagrama
em seguida:
\hfill \break
\xymatrix@C=20cm{
    \ensuremath{\Conid{MagicNo}\times(\Conid{Time}\times\Conid{Transactions})}
           \ar[d]_-{\ensuremath{\p2\comp \p2}}
\\
    \ensuremath{\Conid{Transactions}}
}
\hfill \break

Deste modo, fica definido \ensuremath{\Varid{b0}} como:
\begin{eqnarray*}
\ensuremath{\Varid{b0}\mathrel{=}\p2\comp \p2}
\end{eqnarray*}


\item Descobrir \ensuremath{\Varid{joint}}

Tendo em conta o domínio da função \ensuremath{\Varid{joint}}, ou seja, \ensuremath{\Conid{Block}\times\Conid{Transactions}},
percebemos que o objetivo desta função será retirar de \ensuremath{\Conid{Block}} as suas
\ensuremath{\Conid{Transactions}} e juntá-las às \ensuremath{\Conid{Transactions}} já acumuladas (passadas como
parâmetro).

Assim, uma definição de \ensuremath{\Varid{joint}} \ensuremath{\Varid{pointwise}} é:
\begin{eqnarray*}
\ensuremath{\Varid{joint}\;(\Varid{block},\Varid{transac})\mathrel{=}(\p2\;(\p2\;\Varid{block}))\plus \Varid{transac}}
\end{eqnarray*}

Esta função cumpre os requisitos a que a proposemos, uma vez que retira de
\ensuremath{\Conid{Block}} as \ensuremath{\Conid{Transactions}}, e concatena-as às \ensuremath{\Conid{Transactions}} passadas como parâmetro.

\end{enumerate}

Temos então a definição de \ensuremath{\Varid{b0}} e \ensuremath{\Varid{joint}}, pelo que ficamos a saber qual é o gene g:
\begin{eqnarray*}
\start
\ensuremath{\Varid{g}\mathrel{=}\alt{\Varid{b0}}{\Varid{joint}}}
%
\just\equiv{ Definição de b0 ; Definição de joint }
%
\ensuremath{\Varid{g}\mathrel{=}\alt{\p2\comp \p2}{\Varid{joint}}}
\more
\ensuremath{\mathbf{where}\;\Varid{joint}\;(\Varid{x},\Varid{y})\mathrel{=}(\p2\;(\p2\;\Varid{x}))\plus \Varid{y}}
%
\end{eqnarray*}


Deste modo, está definida a função \ensuremath{\Varid{allTransactions}} pedida:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{allTransactions}\;\Varid{a}\mathrel{=}\Varid{cataBlockchain}\;\alt{\p2\comp \p2}{\Varid{joint}}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{joint}\;(\Varid{x},\Varid{y})\mathrel{=}(\p2\;(\p2\;\Varid{x}))\plus \Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\item Função \ensuremath{\Varid{ledger}}

O objetivo desta função é calcular o valor disponível de cada entidade numa
dada block chain.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{groupL}\mathbin{::}\Conid{Ledger}\to \Conid{Ledger}{}\<[E]%
\\
\>[B]{}\Varid{groupL}\;\Varid{t}\mathrel{=}(\Varid{sums}\comp \map \;(\Varid{mapFst}\;\Varid{head}\comp \Varid{unzip})\comp \Varid{groupBy}\;(\lambda \Varid{x}\;\Varid{y}\to \p1\;\Varid{x}\equiv \p1\;\Varid{y})\comp \Varid{sort})\;\Varid{t}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{mapFst}\;\Varid{f}\;(\Varid{a},\Varid{b})\mathrel{=}(\Varid{f}\;\Varid{a},\Varid{b}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{sums}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{sums}\;((\Varid{a},\Varid{b})\mathbin{:}\Varid{t})\mathrel{=}(\Varid{a},\Varid{sum}\;\Varid{b})\mathbin{:}\Varid{sums}\;\Varid{t}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{ledger}\;\Varid{a}\mathrel{=}\Varid{groupL}\;(\Varid{cataList}\;\alt{\Varid{nil}}{\Varid{insert}}\;(\Varid{allTransactions}\;\Varid{a})){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{insert}\;(\Varid{x},\Varid{y})\mathrel{=}(\p1\;\Varid{x},\mathbin{-}\p1\;(\p2\;\Varid{x}))\mathbin{:}(\p2\;(\p2\;\Varid{x}),\p1\;(\p2\;\Varid{x}))\mathbin{:}\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks




TODOOOO

\ensuremath{\mathbf{type}\;\Conid{Transaction}\mathrel{=}(\Conid{Entity},(\Conid{Value},\Conid{Entity}))}
\ensuremath{\mathbf{type}\;\Conid{Transactions}\mathrel{=}[\mskip1.5mu \Conid{Transaction}\mskip1.5mu]}

\ensuremath{\mathbf{type}\;\Conid{Ledger}\mathrel{=}[\mskip1.5mu (\Conid{Entity},\Conid{Value})\mskip1.5mu]}

\ensuremath{\mathbf{type}\;\Conid{Block}\mathrel{=}(\Conid{MagicNo},(\Conid{Time},\Conid{Transactions}))}









\item Função \ensuremath{\Varid{isValidMagicNr}}

\end{enumerate}










----

\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
           \ar[d]_-{\ensuremath{\cata{\Varid{g}}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\cata{\Varid{g}}}}
           \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
     \ensuremath{\mathit B}
&
     \ensuremath{\mathrm{1}\mathbin{+}\mathit B}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}




\begin{eqnarray*}
\xymatrix@C=3cm{
   \ensuremath{\Conid{A}\mathbin{*}}
          \ar[d]_-{\ensuremath{\Varid{ana}\;\Varid{lsplitBGene}}}
           \ar[r]^-{\ensuremath{\Varid{lsplitBGene}}}
&
   \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\mathbin{*}\times(\Conid{A}\times\Conid{A}\;\Varid{above})\;\Varid{above}}
          \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}((\Varid{ana}\;\Varid{lsplitBGene})\times\map \;(\Varid{id}\times\Varid{ana}\;\Varid{lsplitBGene}))}}
\\
    \ensuremath{\mathit B}
       \ar[d]_-{\ensuremath{\Varid{cata}\;\Varid{inordBGene}}}
       \ar[r]^-{\ensuremath{\Varid{outB}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\mathit B\times(\Conid{A}\times\mathit B)\;\Varid{above}}
          \ar[l]^-{\ensuremath{\Varid{inB}}}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}((\Varid{cata}\;\Varid{inordBGene})\times\map \;(\Varid{id}\times\Varid{cata}\;\Varid{inordBGene}))}}
\\
   \ensuremath{\Conid{A}\;\Varid{above}}
&
   \ensuremath{\mathrm{1}\mathbin{+}\Conid{A}\;\Varid{above}\times(\Conid{A}\times\Conid{A}\;\Varid{above})\;\Varid{above}}
       \ar[l]^-{\ensuremath{\Varid{inordBGene}}}
}
\end{eqnarray*}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{isValidMagicNr}\;\Varid{a}\mathrel{=}\Varid{all}\;((\equiv )\;\mathrm{1}\comp \length )\comp \Varid{group}\comp \Varid{sort}\mathbin{\$}\Varid{cataBlockchain}\;\alt{\Varid{list}}{\Varid{insert}}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;{}\<[13]%
\>[13]{}\Varid{list}\;\Varid{x}\mathrel{=}[\mskip1.5mu \p1\;\Varid{x}\mskip1.5mu]{}\<[E]%
\\
\>[13]{}\Varid{insert}\;(\Varid{x},\Varid{y})\mathrel{=}(\p1\;\Varid{x})\mathbin{:}\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection*{Problema 2}

O segundo problema tem como tema uma estrutura de dados que é muito utilizada para
representação e processamento de imagens- quadtrees. Tal como é referido no
enunciado do problema, uma quadtree é uma árvore quaternária em
que cada nodo tem quatro sub-árvores e cada folha representa um valor bi-dimensional.

Antes de procedermos ao desenvolvimento das funções propostas neste problema
definimos algumas funções que nos serão muito úteis.

\vspace{0.5cm}

Uma \ensuremath{\Conid{QTree}} poderá ser:
\begin{eqnarray*}
\ensuremath{\Conid{Cell}\;\Varid{a}\;\Conid{Int}\;\Conid{Int}}
\end{eqnarray*}
Ou
\begin{eqnarray*}
\ensuremath{\Conid{Block}\;(\Conid{QTree}\;\Varid{a})\;(\Conid{QTree}\;\Varid{a})\;(\Conid{QTree}\;\Varid{a})\;(\Conid{QTree}\;\Varid{a})}
\end{eqnarray*}

Em consequência, as definições de \ensuremath{\Varid{inQTree}} e \ensuremath{\Varid{outQTree}} terão que ser as seguintes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inQTree}\mathrel{=}\alt{\Varid{uncurryCell}}{\Varid{uncurryBlock}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{uncurryCell}\;(\Varid{e},(\Varid{n1},\Varid{n2}))\mathrel{=}\Conid{Cell}\;\Varid{e}\;\Varid{n1}\;\Varid{n2}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{uncurryBlock}\mathbin{::}(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))\to \Conid{QTree}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{uncurryBlock}\;(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4})))\mathrel{=}\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{outQTree}\;(\Conid{Cell}\;\Varid{e}\;\Varid{n1}\;\Varid{n2})\mathrel{=}i_1\;(\Varid{e},(\Varid{n1},\Varid{n2})){}\<[E]%
\\
\>[B]{}\Varid{outQTree}\;(\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4})\mathrel{=}i_2\;(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O diagrama da função \ensuremath{\Varid{inQTree}} é o seguinte:
\begin{eqnarray*}
\xymatrix@C=2cm{
     \ensuremath{\Conid{QTree}\;\Varid{a}}
&
     \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[l]^-{\ensuremath{\Varid{inQTree}}}
}
\end{eqnarray*}

E o diagrama da função \ensuremath{\Varid{outQTree}} é o seguinte:
\begin{eqnarray*}
\xymatrix@C=2cm{
     \ensuremath{\Conid{QTree}\;\Varid{a}}
           \ar[r]_-{\ensuremath{\Varid{outQTree}}}
&
     \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
}
\end{eqnarray*}


No caso da função \ensuremath{\Varid{inQTree}}, que "fecha" a \ensuremath{\Conid{QTree}}, o retorno deverá ser uma \ensuremath{\Conid{QTree}}, logo, no
caso da \ensuremath{\Conid{Cell}} (lado esquerdo do \ensuremath{\mathbin{+}}) temos que ajustar o parâmetro recebido \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))}
devolvendo \ensuremath{\Conid{Cell}\;\Varid{a}\;\Conid{Int}\;\Conid{Int}}, para assim a função devolver a informação
no tipo de dados correto. No caso do \ensuremath{\Conid{Block}}, recebendo
\ensuremath{(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4})))} teremos que retornar \ensuremath{\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4}}.
Esta função é definida como um ``either'' porque temos estas duas "hipóteses"
de tipo de dados dentro do tipo de dados \ensuremath{\Conid{QTree}}.

\vspace{0.2cm}

No caso da função \ensuremath{\Varid{outQTree}} o raciocínio é o inverso. Uma vez que esta função
recebe uma \ensuremath{\Conid{QTree}} podemos definir a função com dois casos diferentes, tal como
se pode ver na solução por nós proposta.

Os dois diagramas em seguida ajudam-nos a perceber melhor como tratar os dois
casos de \ensuremath{\Conid{QTree}} na função \ensuremath{\Varid{outQTree}}:

\hfill \break
\xymatrix@C=20cm{
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))}
           \ar[d]_-{\ensuremath{i_1}}
\\
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
}
\hfill \break

e

\hfill \break
\xymatrix@C=20cm{
    \ensuremath{(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[d]_-{\ensuremath{i_2}}
\\
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
}
\hfill \break

Assim, quando recebemos uma \ensuremath{\Conid{Cell}\;\Varid{e}\;\Varid{n1}\;\Varid{n2}} o objetivo será
injetá-la à esquerda de modo a respeitar o tipo de dados, devolvendo
então: \ensuremath{i_1\;(\Varid{e},(\Varid{n1},\Varid{n2}))}. No caso de \ensuremath{\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4}}, injetamos
à direita retornando: \ensuremath{i_2\;(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4})))}.

\vspace{0.5cm}

Outras funções cruciais para a resolução deste problema são as seguintes:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{baseQTree}\;\Varid{f}\;\Varid{g}\mathrel{=}(\Varid{f}\times\Varid{id})+(\Varid{g}\times(\Varid{g}\times(\Varid{g}\times\Varid{g}))){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recQTree}\;\Varid{g}\mathrel{=}\Varid{baseQTree}\;\Varid{id}\;\Varid{g}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{cataQTree}\;\Varid{g}\mathrel{=}\Varid{g}\comp (\Varid{recQTree}\;(\Varid{cataQTree}\;\Varid{g}))\comp \Varid{outQTree}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{anaQTree}\;\Varid{g}\mathrel{=}\Varid{inQTree}\comp (\Varid{recQTree}\;(\Varid{anaQTree}\;\Varid{g}))\comp \Varid{g}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hyloQTree}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{cataQTree}\;\Varid{h}\comp \Varid{anaQTree}\;\Varid{g}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


Para melhor compreensão do intuito de cada uma delas desenhamos dois diagramas:

O primeiro, mostra a função \ensuremath{\Varid{baseQTree}}. Atendendo ao seu tipo,
já contido no enunciado, conseguimos perceber qual é o objetivo desta função.
A título de exemplo, vamos considerar que f tem um tipo: \ensuremath{\Varid{f}\mathbin{::}\Conid{A}\to \Conid{E}}
e que g tem um tipo: \ensuremath{\Varid{g}\mathbin{::}\mathit C\to \Conid{D}}:

\hfill \break
\xymatrix@C=20cm{
    \ensuremath{(\Varid{a},\Varid{b})+(\Varid{c},(\Varid{c},(\Varid{c},\Varid{c})))}
           \ar[d]_-{baseQTree f g}
\\
    \ensuremath{(\Varid{e},\Varid{b})+(\Varid{d},(\Varid{d},(\Varid{d},\Varid{d})))}
}
\hfill \break

Assim, percebemos de imediata que a função \ensuremath{\Varid{baseQTree}} terá que ser definida como
\ensuremath{(\Varid{f}\times\Varid{id})\mathbin{+}(\Varid{g}\times(\Varid{g}\times(\Varid{g}\times\Varid{g})))}:

\hfill \break
\xymatrix@C=20cm{
    \ensuremath{(\Varid{a},\Varid{b})+(\Varid{c},(\Varid{c},(\Varid{c},\Varid{c})))}
           \ar[d]_-{\ensuremath{(\Varid{f}\times\Varid{id})\mathbin{+}(\Varid{g}\times(\Varid{g}\times(\Varid{g}\times\Varid{g})))}}
\\
    \ensuremath{(\Varid{e},\Varid{b})+(\Varid{d},(\Varid{d},(\Varid{d},\Varid{d})))}
}
\hfill \break

\vspace{0.4cm}

O segundo, que é um pouco mais complexo, é apenas um exemplo do que se pode
fazer com a combinação destas funções, nomedamente \ensuremath{\Varid{inQTree}}, \ensuremath{\Varid{outQTree}},
\ensuremath{\Varid{recQTree}}, \ensuremath{\Varid{cataQTree}}, \ensuremath{\Varid{anaQTree}} e \ensuremath{\Varid{hyloQTree}}. Vamos assumir que neste nosso diagrama
as funções \ensuremath{\Varid{g}} e \ensuremath{\Varid{h}} mencionadas são funções que devolvem a identidade, ou seja,
não alteram o conteúdo da \ensuremath{\Conid{QTree}}, mas respeitam os tipos de dados ideais:
\begin{eqnarray*}
\xymatrix@C=3cm{
   \ensuremath{\Conid{QTree}\;\Varid{a}}
          \ar[d]_-{\ensuremath{\Varid{anaQTree}\;\Varid{g}}}
           \ar[r]^-{\ensuremath{\Varid{g}}}
&
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
          \ar[d]^{\ensuremath{\Varid{recQTree}\;(\Varid{anaQTree}\;\Varid{g})}}
\\
    \ensuremath{\Conid{QTree}\;\Varid{a}}
       \ar[d]_-{\ensuremath{\Varid{cataQTree}\;\Varid{h}}}
       \ar[r]^-{\ensuremath{\Varid{outQTree}}}
&
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
          \ar[l]^-{\ensuremath{\Varid{inQTree}}}
           \ar[d]^{\ensuremath{\Varid{recQTree}\;(\Varid{cataQTree}\;\Varid{h})}}
\\
   \ensuremath{\Conid{QTree}\;\Varid{a}}
&
   \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
       \ar[l]^-{\ensuremath{\Varid{h}}}
}
\end{eqnarray*}

A função \ensuremath{\Varid{hyloQTree}} é definida como sendo \ensuremath{\Varid{hyloQTree}\;\Varid{h}\;\Varid{g}\mathrel{=}\Varid{cataQTree}\;\Varid{h}\comp \Varid{anaQTree}\;\Varid{g}},
ou seja, no diagrama anterior pode ser identificado por uma seta vertical que vai desde o
argumento da função \ensuremath{\Varid{anaQTree}} até ao retorno da função \ensuremath{\Varid{cataQTree}}.

Assim, com a ajuda destes diagramas, encontramos as definições procuradas.

\vspace{0.5cm}

Por fim, temos \ensuremath{\mathsf{fmap}}, que tem como objetivo aplicar a função \ensuremath{\Varid{f}} a todas
as \ensuremath{\Conid{Cell}} da \ensuremath{\Conid{QTree}}, mais especificamente ao conteúdo da \ensuremath{\Conid{Cell}} que diz respeito ao
valor/ objeto da matriz (não à dimensão). A função simplesmente aplica a todos esses elementos
a função \ensuremath{\Varid{f}}.

Assim, decidimos definir a nossa função \ensuremath{\mathsf{fmap}} da seguinte forma:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Functor}\;\Conid{QTree}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathsf{fmap}\;\Varid{f}\mathrel{=}\Varid{cataQTree}\;(\Varid{inQTree}\comp \Varid{baseQTree}\;\Varid{f}\;\Varid{id}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

No seguinte diagrama conseguimos perceber o que é que as funções
\ensuremath{\Varid{inQTree}\comp \Varid{baseQTree}\;\Varid{f}\;\Varid{id}} fazem, considerando que f é uma função
do tipo: \ensuremath{\Varid{f}\mathbin{::}\Conid{A}\to \Conid{E}}:

\hfill \break
\xymatrix@C=20cm{
    \ensuremath{(\Varid{a},\Varid{b})+(\Varid{c},(\Varid{c},(\Varid{c},\Varid{c})))}
       \ar[d]_-{\ensuremath{\Varid{baseQTree}\;\Varid{f}\;\Varid{id}}}
\\
    \ensuremath{(\Varid{e},\Varid{b})+(\Varid{c},(\Varid{c},(\Varid{c},\Varid{c})))}
       \ar[d]_-{\ensuremath{\Varid{inQTree}}}
\\
    \ensuremath{\Conid{QTree}\;\Varid{e}}
}

Ou seja, numa primeira fase a função \ensuremath{\Varid{baseQTree}\;\Varid{f}\;\Varid{id}} aplica a função \ensuremath{\Varid{f}} ao
conteúdo da \ensuremath{\Conid{Cell}} e numa segunda fase a função \ensuremath{\Varid{inQTree}} junta o resultado
da aplicação da função \ensuremath{\Varid{baseQTree}\;\Varid{f}\;\Varid{id}} numa \ensuremath{\Conid{QTree}}.


Assim, aplicando um \ensuremath{\Varid{cataQTree}} a esta composição de funções construímos:
\begin{eqnarray*}
\xymatrix@C=3cm{
    \ensuremath{\Conid{QTree}\;\Varid{a}}
           \ar[d]_-{\ensuremath{\Varid{cataQTree}\;\Varid{g}}}
&
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[d]^{\ensuremath{\Varid{recQTree}\;(\Varid{cataQTree}\;\Varid{g})}}
           \ar[l]_-{\ensuremath{\Varid{inQTree}}}
\\
     \ensuremath{\Conid{QTree}\;\Varid{e}}
&
     \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{e},(\Conid{QTree}\;\Varid{e},(\Conid{QTree}\;\Varid{e},\Conid{QTree}\;\Varid{e})))}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

Sendo \ensuremath{\Varid{g}\;\Varid{f}\mathrel{=}\Varid{inQTree}\comp \Varid{baseQTree}\;\Varid{f}\;\Varid{id}}.

Em suma, tal como nos diz a própria definição de
catamorfismo, na seta vertical mais à direita o mesmo é aplicado recursivamente
à parte direita do \ensuremath{\mathbin{+}} (o \ensuremath{\Conid{Functor}}, ou seja, \ensuremath{\Varid{recQTree}} encarrega-se disso) e,
depois disso, temos então a "cauda" processada, tal como podemos ver no diagrama.
O nosso gene \ensuremath{\Varid{g}}
responsabiliza-se pelo último passo de transformar na \ensuremath{\Conid{Cell}} (lado
esquerdo do \ensuremath{\mathbin{+}} inferior) o seu conteúdo (através da função \ensuremath{\Varid{f}}) e de juntar tudo numa só
\ensuremath{\Conid{QTree}}.

\vspace{0.3cm}

Agora reunimos todas as condições para nos concentrarmos no desenvolvimento das
alíneas deste problema.

\begin{enumerate}

\item Função \ensuremath{\Varid{rotateQTree}}

O objetivo desta função é rodar uma \ensuremath{\Conid{QTree}}.

Optamos por utilizar um catamorfismo para definir
esta função. Assim, temos que \ensuremath{\Varid{rotateQTree}\mathrel{=}\Varid{cataQTree}\;\Varid{g}}.
Tendo em conta a definição de \ensuremath{\Varid{cataQTree}} podemos definir \ensuremath{\Varid{g}}
como um ``either'', onde um dos lados irá tratar a \ensuremath{\Conid{Cell}} e o outro
o \ensuremath{\Conid{Block}}.

Consequentemente, para perceber que impacto esta função \ensuremath{\Varid{rotateQTree}}
terá na \ensuremath{\Conid{QTree}} analisamos a matriz de bits (Figura~\ref{fig:bm}) e a
respetiva codificação em quadtrees (Figura~\ref{fig:qt}).

Vamos agora exemplificar o nosso raciocínio com alguns exemplos:

Numa primeira fase iremos analisar o que acontecerá numa \ensuremath{\Conid{Cell}}.
Por exemplo, se tivermos a \ensuremath{\Conid{Cell}}:
\begin{tabbing}\ttfamily
~\char40{}~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~\char41{}
\end{tabbing}

Que é representada por \ensuremath{\Conid{Cell}\;\mathrm{0}\;\mathrm{4}\;\mathrm{2}}, rodando-a $90º$ fica:
\begin{tabbing}\ttfamily
~\char40{}~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~\char41{}
\end{tabbing}
Que é representada por \ensuremath{\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{4}}.

Logo, fica implícito que no que diz respeito a rodar uma \ensuremath{\Conid{Cell}} o que
acontece é que as suas dimensões verticais e horizontais trocam.

Definimos então a função \ensuremath{\Varid{rotateCell}} que roda uma \ensuremath{\Conid{Cell}}:
\begin{eqnarray*}
\ensuremath{\Varid{rotateCell}\;(\Varid{e},(\Varid{n1},\Varid{n2}))\mathrel{=}\Conid{Cell}\;\Varid{e}\;\Varid{n2}\;\Varid{n1}}
\end{eqnarray*}

O tipo desta função terá que ser o acima apresentado tendo em consideração
os tipos da função \ensuremath{\Varid{cataQTree}} e \ensuremath{\Varid{inQTree}}.

\vspace{0.5cm}

Numa segunda fase analisamos o que acontece num \ensuremath{\Conid{Block}}.

Procedendo da mesma forma, definimos um \ensuremath{\Conid{Block}} de exemplo:
\begin{tabbing}\ttfamily
~\char40{}~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~\char41{}
\end{tabbing}

Que é definida por \ensuremath{\Conid{Block}\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})}.

Rodando o \ensuremath{\Conid{Block}} $90º$:
\begin{tabbing}\ttfamily
~\char40{}~1~1~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~0~0~\char41{}\\
\ttfamily ~\char40{}~1~1~0~0~\char41{}
\end{tabbing}

Ficamos com uma \ensuremath{\Conid{Block}\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})}.

Assim, percebemos que os quatro parâmetros de \ensuremath{\Conid{Block}} rodam entre si.
O primeiro parâmetro passará a ser o segundo parâmetro, o segundo passará
a ser o último, o terceiro fica em primeiro e, por fim, o último parâmetro
fica a ser o terceiro.

Conseguimos então perceber a definição que trata o \ensuremath{\Conid{Block}}:
\begin{eqnarray*}
\ensuremath{\Varid{rotateBlock}\;(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4})))\mathrel{=}\Conid{Block}\;\Varid{q3}\;\Varid{q1}\;\Varid{q4}\;\Varid{q2}}
\end{eqnarray*}

Assim, temos todas as condições necessárias para definir a função
pedida, \ensuremath{\Varid{rotateQTree}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rotateQTree}\mathrel{=}\Varid{cataQTree}\;\alt{\Varid{rotateCell}}{\Varid{rotateBlock}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{rotateCell}\;(\Varid{e},(\Varid{n1},\Varid{n2}))\mathrel{=}\Conid{Cell}\;\Varid{e}\;\Varid{n2}\;\Varid{n1}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{rotateBlock}\;(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4})))\mathrel{=}\Conid{Block}\;\Varid{q3}\;\Varid{q1}\;\Varid{q4}\;\Varid{q2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O diagrama desta função é o seguinte:
\begin{eqnarray}
\xymatrix@C=2cm{
    \ensuremath{\Conid{QTree}\;\Varid{a}}
           \ar[d]_-{\ensuremath{\Varid{cataQTree}\;\Varid{g}}}
&
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[d]^{\ensuremath{\Varid{recQTree}\;(\Varid{cataQTree}\;\Varid{g})}}
           \ar[l]_-{\ensuremath{\Varid{inQTree}}}
\\
     \ensuremath{\Conid{QTree}\;\Varid{a}}
&
     \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray}

Onde:
\begin{eqnarray*}
\start
\ensuremath{\Varid{g}\mathrel{=}\alt{\Varid{rotateCell}}{\Varid{rotateBlock}}}
\more
\ensuremath{\mathbf{where}\;\Varid{rotateCell}\;(\Varid{e},(\Varid{n1},\Varid{n2}))\mathrel{=}\Conid{Cell}\;\Varid{e}\;\Varid{n2}\;\Varid{n1}}
\more
\ensuremath{\Varid{rotateBlock}\;(\Varid{q1},(\Varid{q2},(\Varid{q3},\Varid{q4})))\mathrel{=}\Conid{Block}\;\Varid{q3}\;\Varid{q1}\;\Varid{q4}\;\Varid{q2}}
\end{eqnarray*}


\item Função \ensuremath{\Varid{scaleQTree}}

Esta função redimensiona uma \ensuremath{\Conid{Qtree}} tendo em consideração o \ensuremath{\Conid{Int}} passado
como parâmetro.

Assim, intuitivamente percebemos que teremos que multiplicar o fator passado
como parâmetro pela dimensão da matriz.

Mais uma vez recorremos a um \ensuremath{\Varid{cataQTree}} para definir a função \ensuremath{\Varid{scaleQTree}}.
Deste modo, utilizando o mesmo raciocínio da função anterior, precisamos de definir
o gene \ensuremath{\Varid{g}} como um ``either'' onde a \ensuremath{\Conid{Cell}} e o \ensuremath{\Conid{Block}} serão tratados
individualmente.

O gene \ensuremath{\Varid{g}} terá a seguinte definição:
\begin{eqnarray*}
\ensuremath{\Varid{g}\;\Varid{n}\mathrel{=}\alt{\Varid{scaleCell}\;\Varid{n}}{\Varid{uncurryBlock}}}
\end{eqnarray*}

Uma vez que as dimensões da matriz são somente responsabilidade da \ensuremath{\Conid{Cell}}
não teremos que alterar nada no \ensuremath{\Conid{Block}}.

De forma a respeitar os tipos, no que diz respeito a tratar o \ensuremath{\Conid{Block}}, utilizamos
a função \ensuremath{\Varid{uncurryBlock}} já definida por nós, que apenas altera a forma como
o \ensuremath{\Conid{Block}} é mostrado, não alterando o seu conteúdo.

Para tratar a \ensuremath{\Conid{Cell}} vamos recorrer a uma função auxiliar, \ensuremath{\Varid{scaleCell}},
cujo único objetivo será multiplicar as dimensões da \ensuremath{\Conid{Cell}} pelo fator e devolvê-la
no tipo de dados correto:
\begin{eqnarray*}
\ensuremath{\Varid{scaleCell}\;\Varid{n}\;(\Varid{e},(\Varid{n1},\Varid{n2}))\mathrel{=}\Conid{Cell}\;\Varid{e}\;(\Varid{n1}\mathbin{*}\Varid{n})\;(\Varid{n2}\mathbin{*}\Varid{n})}
\end{eqnarray*}

O diagrama desta função é o mesmo da função anterior, diagrama (3),
variando somente o gene \ensuremath{\Varid{g}}, que neste caso é o anteriormente referido.

Assim, temos definida a função \ensuremath{\Varid{scaleQTree}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{scaleQTree}\;\Varid{n}\mathrel{=}\Varid{cataQTree}\;\alt{\Varid{scaleCell}\;\Varid{n}}{\Varid{uncurryBlock}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{scaleCell}\;\Varid{n}\;(\Varid{e},(\Varid{n1},\Varid{n2}))\mathrel{=}\Conid{Cell}\;\Varid{e}\;(\Varid{n1}\mathbin{*}\Varid{n})\;(\Varid{n2}\mathbin{*}\Varid{n}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\item Função \ensuremath{\Varid{invertQTree}}

O intuito da função \ensuremath{\Varid{invertQTree}} é inverter as cores de uma quadtree. Assim,
terá obrigatoriamente de se tratar de uma matriz de píxeis, neste caso de \ensuremath{\Conid{PixelRGBA8}}.
É nos também dito que o pixel pode ser invertido calculando (255 - w), sendo w
a componente de cor RGB.

Logo, utilizando o mesmo raciocínio da função \ensuremath{\Varid{scaleQTree}}, vamos definir
a função \ensuremath{\Varid{invertQTree}} como um \ensuremath{\Varid{cataQTree}} onde também somente a \ensuremath{\Conid{Cell}}
precisa de ser modificada, tendo em conta que é a \ensuremath{\Conid{Cell}} que possui o contéudo
da \ensuremath{\Conid{QTree}}, ou seja, o parâmetro que nos interessa alterar.

Logo, teremos um gene \ensuremath{\Varid{g}} com a seguinte definição:
\begin{eqnarray*}
\ensuremath{\Varid{g}\mathrel{=}\alt{\Varid{invertCell}}{\Varid{uncurryBlock}}}
\end{eqnarray*}

Precisamos então somente de definir a função \ensuremath{\Varid{invertCell}}, que poderá
ser definida como:
\begin{eqnarray*}
\start
\ensuremath{\Varid{invertCell}\;((\Conid{PixelRGBA8}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{d}),(\Varid{n1},\Varid{n2}))\mathrel{=}}
\more
\ensuremath{\Conid{Cell}\;(\Conid{PixelRGBA8}\;(\mathrm{255}\mathbin{-}\Varid{a})\;(\mathrm{255}\mathbin{-}\Varid{b})\;(\mathrm{255}\mathbin{-}\Varid{c})\;(\mathrm{255}\mathbin{-}\Varid{d}))\;\Varid{n1}\;\Varid{n2}}
\end{eqnarray*}

Esta função pode também ser ilustrada através do diagrama (3), mas com um gene \ensuremath{\Varid{g}}
definido como o mencionado anteriormente.

Consequentemente, temos todas as condições necessárias para definir
a função \ensuremath{\Varid{invertQTree}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{invertQTree}\mathrel{=}\Varid{cataQTree}\;\alt{\Varid{invertCell}}{\Varid{uncurryBlock}}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{invertCell}\;((\Conid{PixelRGBA8}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{d}),(\Varid{n1},\Varid{n2}))\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{12}{}\<[17]%
\>[17]{}\Conid{Cell}\;(\Conid{PixelRGBA8}\;(\mathrm{255}\mathbin{-}\Varid{a})\;(\mathrm{255}\mathbin{-}\Varid{b})\;(\mathrm{255}\mathbin{-}\Varid{c})\;(\mathrm{255}\mathbin{-}\Varid{d}))\;\Varid{n1}\;\Varid{n2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\item Função \ensuremath{\Varid{compressQTree}}

O objetivo desta função é comprimir a \ensuremath{\Conid{QTree}} cortando folhas da árvore de modo
a reduzir a sua profundidade num dado número de níveis, passado como parâmetro na função.
Basicamente, o que irá acontecer à imagem é perder informação e por isso ``desfocar''.

Para o desenvolvimento desta função recorremos a uma \ensuremath{\Varid{anaQTree}} uma vez que
consideramos que seria mais simples de tratar o problema usando esse
conceito/ definição.

De uma forma mais concreta, pensamos em utilizar uma \ensuremath{\Varid{anaQTree}} uma vez que sabiamos que
ela se iria concentrar em cada nível da árvore gradualmente, começando
da raiz até às folhas. Assim, de uma forma geral, pensamos
que a nossa \ensuremath{\Varid{anaQTree}} deveria ter um gene que averigua-se se estamos no
nível desejado e em caso afirmativa eliminasse toda a \ensuremath{\Conid{QTree}} a partir desse nível.


Assim, passamos para o chamado desenvolvimento do problema:

Temos por exemplo \ensuremath{\Conid{QTree}} da Figura~\ref{fig:qt},
que é representada pela \ensuremath{\Conid{QTree}\;\Varid{qt}}, que já vinha também no enunciado:
\begin{eqnarray*}
\start
\ensuremath{\Varid{qt}\mathrel{=}\Conid{Block}}
\more
\ensuremath{(\Conid{Cell}\;\mathrm{0}\;\mathrm{4}\;\mathrm{4})}
\more
\ensuremath{(\Conid{Block}\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Block}\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{1}\;\mathrm{1})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{1})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{1})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{1})))}
\more
\ensuremath{(\Conid{Cell}\;\mathrm{1}\;\mathrm{4}\;\mathrm{4})}
\more
\ensuremath{(\Conid{Block}\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Block}\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{1})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{1})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{1})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{1}\;\mathrm{1})))}
\end{eqnarray*}

\begin{figure}
\begin{center}
\includegraphics[width=0.4\textwidth]{imgs/qt.png}
\end{center}
\caption{Esquema da \ensuremath{\Conid{QTree}\;\Varid{qt}}.}
\label{fig:qt}
\end{figure}


Se quisermos aplicar a função \ensuremath{\Varid{compressQTree}\;\mathrm{2}}, ou seja, comprimir
dois níveis, o esquema da \ensuremath{\Conid{QTree}} de retorno deverá ser o seguinte
o esquema presenta na Figura~\ref{fig:qtcompress2}, representado por:
\begin{eqnarray*}
\start
\ensuremath{\Varid{qt\char95 compress2}\mathrel{=}\Conid{Block}}
\more
\ensuremath{(\Conid{Cell}\;\mathrm{0}\;\mathrm{4}\;\mathrm{4})}
\more
\ensuremath{(\Conid{Cell}\;\mathrm{0}\;\mathrm{4}\;\mathrm{4})}
\more
\ensuremath{(\Conid{Cell}\;\mathrm{1}\;\mathrm{4}\;\mathrm{4})}
\more
\ensuremath{(\Conid{Cell}\;\mathrm{1}\;\mathrm{4}\;\mathrm{4})}
\end{eqnarray*}

\begin{figure}
\begin{center}
\includegraphics[width=0.4\textwidth]{imgs/qtcompress2.png}
\end{center}
\caption{Esquema da \ensuremath{\Conid{QTree}\;\Varid{qt}} comprimida em 2 níveis.}
\label{fig:qtcompress2}
\end{figure}

Deste modo, apercebemo-nos que teriamos que ter uma função que nos ``cortasse'' todos
os ramos da \ensuremath{\Conid{QTree}} a abolir. Percebemos através da Figura~\ref{fig:qt}
e da Figura~\ref{fig:qtcompress2} que
se essa função, que poderá chamar-se \ensuremath{\Varid{corta}}, receber como parâmetro a parte da
\ensuremath{\Conid{Qtree}} a eliminar deveremos transforma-la numa única \ensuremath{\Conid{Cell}}.

Nesta fase, tivemos que perceber quais as dimensões da \ensuremath{\Conid{Cell}}
resultado pelo que, por exemplo, se tivermos:
\begin{eqnarray*}
\ensuremath{\Conid{Block}\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{3}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{2}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{1}\;\mathrm{4}\;\mathrm{2})\;(\Conid{Cell}\;\mathrm{0}\;\mathrm{1}\;\mathrm{2})}
\end{eqnarray*}

Representado por:
\begin{tabbing}\ttfamily
~\char40{}~0~0~0~1~1~\char41{}\\
\ttfamily ~\char40{}~0~0~0~1~1~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~0~\char41{}\\
\ttfamily ~\char40{}~1~1~1~1~0~\char41{}
\end{tabbing}


A \ensuremath{\Conid{Cell}} resultado deverá ser:
\begin{eqnarray*}
\start
\ensuremath{\Conid{Cell}\;\mathrm{0}\;\mathrm{5}\;\mathrm{4}}
\end{eqnarray*}

E em modo matriz:
Representado por:
\begin{tabbing}\ttfamily
~\char40{}~0~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~0~\char41{}\\
\ttfamily ~\char40{}~0~0~0~0~0~\char41{}
\end{tabbing}

Assim, percebemos que se o \ensuremath{\Conid{Block}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{d}} for então constítuido apenas com \ensuremath{\Conid{Cell}},
ou seja, \ensuremath{\Varid{a},\Varid{b},\Varid{c},\Varid{d}\mathbin{::}\Conid{Cell}}, as dimensões resultado deverão ser calculadas da seguinte
forma:
\begin{eqnarray*}
\start
       \ensuremath{\Varid{corta}\;(\Conid{Block}\;(\Conid{Cell}\;\Varid{c1}\;\Varid{n1}\;\Varid{n2})\;(\Conid{Cell}\;\Varid{c2}\;\Varid{m1}\;\Varid{m2})\;(\Conid{Cell}\;\Varid{c3}\;\Varid{k1}\;\Varid{k2})\;(\Conid{Cell}\;\Varid{c4}\;\Varid{o1}\;\Varid{o2}))\mathrel{=}}
\more
        \ensuremath{\Conid{Cell}\;(\Varid{c1})\;(\Varid{n1}\mathbin{+}\Varid{m1})\;(\Varid{n2}\mathbin{+}\Varid{k2})}
\end{eqnarray*}

Optamos por dar como resultado o valor da primeira \ensuremath{\Conid{Cell}}, que no nosso caso é c1.


No caso de o \ensuremath{\Conid{Block}} ainda não ser constituído por apenas \ensuremath{\Conid{Cell}}, tal como referimos
anteriormente, aplicamos recursivamente a função \ensuremath{\Varid{corta}} a cada um dos "argumentos"
de \ensuremath{\Conid{Block}}, e ao próprio \ensuremath{\Conid{Block}}, até conseguirmos chegar a um \ensuremath{\Conid{Block}} só com
\ensuremath{\Conid{Cell}} e o convertermos para \ensuremath{\Conid{Cell}} da forma já referida.
A recursividade irá tratar de nos fornecer a solução que desejamos.
Para esta hipótese a função \ensuremath{\Varid{corta}} será então:
\begin{eqnarray*}
       \ensuremath{\Varid{corta}\;(\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4})\mathrel{=}\Varid{corta}\;(\Conid{Block}\;(\Varid{corta}\;\Varid{q1})\;(\Varid{corta}\;\Varid{q2})\;(\Varid{corta}\;\Varid{q3})\;(\Varid{corta}\;\Varid{q4}))}
\end{eqnarray*}

Pensando no caso de quando esta função é aplicada a somente uma \ensuremath{\Conid{Cell}} isolada a função deverá
retornar a \ensuremath{\Conid{Cell}} argumento exatamente igual:
\begin{eqnarray*}
       \ensuremath{\Varid{corta}\;(\Conid{Cell}\;\Varid{a}\;\Varid{b}\;\Varid{c})\mathrel{=}\Conid{Cell}\;\Varid{a}\;\Varid{b}\;\Varid{c}}
\end{eqnarray*}

Juntando estas 3 hipóteses, temos então a função \ensuremath{\Varid{corta}} definida:
\begin{eqnarray*}
\start
        \ensuremath{\Varid{corta}\;(\Conid{Cell}\;\Varid{a}\;\Varid{b}\;\Varid{c})\mathrel{=}\Conid{Cell}\;\Varid{a}\;\Varid{b}\;\Varid{c}}
\more
        \ensuremath{\Varid{corta}\;(\Conid{Block}\;(\Conid{Cell}\;\Varid{c1}\;\Varid{n1}\;\Varid{n2})\;(\Conid{Cell}\;\Varid{c2}\;\Varid{m1}\;\Varid{m2})\;(\Conid{Cell}\;\Varid{c3}\;\Varid{k1}\;\Varid{k2})\;(\Conid{Cell}\;\Varid{c4}\;\Varid{o1}\;\Varid{o2}))\mathrel{=}}
\more
        \ensuremath{\Conid{Cell}\;(\Varid{c1})\;(\Varid{n1}\mathbin{+}\Varid{m1})\;(\Varid{n2}\mathbin{+}\Varid{k2})}
\more
        \ensuremath{\Varid{corta}\;(\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4})\mathrel{=}\Varid{corta}\;(\Conid{Block}\;(\Varid{corta}\;\Varid{q1})\;(\Varid{corta}\;\Varid{q2})\;(\Varid{corta}\;\Varid{q3})\;(\Varid{corta}\;\Varid{q4}))}
\end{eqnarray*}

Assim, precisamos apenas de definir concretamente, e através de código,
em que momento esta função será aplicada.

Aproveitando a função \ensuremath{\Varid{depthQTree}}, que calcula a profundidade de uma \ensuremath{\Conid{QTree}},
podemos então contruir uma função auxiliar, por exemplo chamada \ensuremath{\Varid{compress}},
que irá receber o número de níveis a eliminar. Como sabemos que o nosso
\ensuremath{\Varid{anaQTree}} irá olhar individualmente para cada nível, a nossa \ensuremath{\Varid{compress}\;\Varid{n}}
averiguará se a profundidade do ramo atual é igual ao número de níveis a cortar.

Podemos utilizar esta técnica pois o anamorfismo percorre cada ramo de cima (raiz)
para baixo e não volta para cima, por isso, quando o sub-ramo tiver uma profundidade
igual ao número de níveis a cortar sabemos que é esse o nível que procuramos,
para podermos aplicar a nossa função \ensuremath{\Varid{corta}}. Se ainda não tivermos chegado
ao nível que procuramos, a função \ensuremath{\Varid{compress}} deverá devolver a \ensuremath{\Conid{QTree}}, ou seja,
o ramo, intacto.

Tivemos que ter em consideração o caso em que o número de níveis a cortar
é maior que toda a profundidade da árvore, sendo que neste caso toda a \ensuremath{\Conid{QTree}}
deverá ser cortada (é aplicada à função \ensuremath{\Varid{cortar}}) ficando somente a \ensuremath{\Conid{Cell}}
comprimida.

É ainda mencionar que, tendo em conta o tipo de \ensuremath{\Varid{anaQTree}}, a nossa \ensuremath{\Varid{compress}}
deverá retornar sempre uma \ensuremath{\Conid{QTree}} ``aberta'' e, assim, aplicamos
a função \ensuremath{\Varid{outQTree}}.


Finalmente, juntando todos estes passos, temos a função \ensuremath{\Varid{compressQTree}} definida:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{corta}\mathbin{::}\Conid{QTree}\;\Varid{a}\to \Conid{QTree}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{corta}\;(\Conid{Cell}\;\Varid{a}\;\Varid{b}\;\Varid{c})\mathrel{=}\Conid{Cell}\;\Varid{a}\;\Varid{b}\;\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{corta}\;(\Conid{Block}\;(\Conid{Cell}\;\Varid{c1}\;\Varid{n1}\;\Varid{n2})\;(\Conid{Cell}\;\Varid{c2}\;\Varid{m1}\;\Varid{m2})\;(\Conid{Cell}\;\Varid{c3}\;\Varid{k1}\;\Varid{k2})\;(\Conid{Cell}\;\Varid{c4}\;\Varid{o1}\;\Varid{o2}))\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{31}{}\<[31]%
\>[31]{}\Conid{Cell}\;(\Varid{c1})\;(\Varid{n1}\mathbin{+}\Varid{m1})\;(\Varid{n2}\mathbin{+}\Varid{k2}){}\<[E]%
\\
\>[B]{}\Varid{corta}\;(\Conid{Block}\;\Varid{q1}\;\Varid{q2}\;\Varid{q3}\;\Varid{q4})\mathrel{=}\Varid{corta}\;(\Conid{Block}\;(\Varid{corta}\;\Varid{q1})\;(\Varid{corta}\;\Varid{q2})\;(\Varid{corta}\;\Varid{q3})\;(\Varid{corta}\;\Varid{q4})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{compressQTree}\;\Varid{n}\mathrel{=}\Varid{anaQTree}\;(\Varid{compress}\;\Varid{n}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{compress}\;\Varid{n}\;\Varid{a}\mid (\Varid{n}\equiv (\Varid{tam}\;\Varid{a})\mathrel{\vee}\Varid{n}\mathbin{>}(\Varid{tam}\;\Varid{a}))\mathrel{=}\Varid{outQTree}\;(\Varid{corta}\;\Varid{a}){}\<[E]%
\\
\>[5]{}\hsindent{19}{}\<[24]%
\>[24]{}\mid \Varid{otherwise}\mathrel{=}\Varid{outQTree}\;\Varid{a}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{tam}\;\Varid{a}\mathrel{=}\Varid{depthQTree}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O anamorfismo que representa esta função é o seguinte:
\begin{eqnarray}
\xymatrix@C=2cm{
    \ensuremath{\Conid{QTree}\;\Varid{a}}
        \ar[d]_-{\ensuremath{\Varid{anaQTree}\;\Varid{g}}}
        \ar[r]^-{\ensuremath{\Varid{g}}}
&
    \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[d]^{\ensuremath{\Varid{recQTree}\;(\Varid{anaQTree}\;\Varid{g})}}
\\
     \ensuremath{\Conid{QTree}\;\Varid{a}}
&
     \ensuremath{(\Varid{a},(\Conid{Int},\Conid{Int}))+(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},(\Conid{QTree}\;\Varid{a},\Conid{QTree}\;\Varid{a})))}
           \ar[l]^-{\ensuremath{\Varid{inQTree}}}
}
\end{eqnarray}


Tal como dizia no enunciado, contruímos as \ensuremath{\Conid{QTrees}} com compressões 1, 2, 3 e 4,
obtendo então, respetivamente, a Figura~\ref{fig:compress1},
a Figura~\ref{fig:compress2}, a Figura~\ref{fig:compress3}
e a Figura~\ref{fig:compress4}.

\begin{figure}
\begin{subfigure}{0.4\textwidth}
    \begin{center}
    \includegraphics[width=0.25\textwidth]{imgs/compress1.png}
    \end{center}
    \caption{Figura Person comprimida em 1 nível.}
    \label{fig:compress1}
\end{subfigure}
\begin{subfigure}{0.4\textwidth}
    \begin{center}
    \includegraphics[width=0.23\textwidth]{imgs/compress2.png}
    \end{center}
    \caption{Figura Person comprimida em 2 níveis.}
    \label{fig:compress2}
\end{subfigure}
\end{figure}

\begin{figure}
\begin{subfigure}{0.4\textwidth}
    \begin{center}
    \includegraphics[width=0.25\textwidth]{imgs/compress3.png}
    \end{center}
    \caption{Figura Person comprimida em 3 níveis.}
    \label{fig:compress3}
\end{subfigure}
\begin{subfigure}{0.4\textwidth}
    \begin{center}
    \includegraphics[width=0.22\textwidth]{imgs/compress4.png}
    \end{center}
    \caption{Figura Person comprimida em 4 níveis.}
    \label{fig:compress4}
\end{subfigure}
\end{figure}


\item Função \ensuremath{\Varid{outlineQTree}}

A função \ensuremath{\Varid{outlineQTree}} recebe uma função que determina quais os píxeis de
fundo e converte uma quadtree numa matriz monocromática, de forma a desenhar o
contorno de uma malha poligonal contina na imagem.

Após analisar o problema e as funções que o enunciado já fornece percebemos
que podemos aproveitar uma função já existente e adaptá-la ao nosso problema.
Esta função é a função \ensuremath{\Varid{qt2bm}}, que converte uma \ensuremath{\Conid{QTree}\;\Varid{a}} em \ensuremath{\Conid{Matrix}\;\Varid{a}}.

\begin{eqnarray*}
\start
\ensuremath{\Varid{qt2bm}\mathbin{::}(\Conid{Eq}\;\Varid{a})\Rightarrow \Conid{QTree}\;\Varid{a}\to \Conid{Matrix}\;\Varid{a}}
\more
\ensuremath{\Varid{qt2bm}\mathrel{=}\Varid{cataQTree}\;\alt{\Varid{f}}{\Varid{g}}\;\mathbf{where}}
\more
\ensuremath{\Varid{f}\;(\Varid{k},(\Varid{i},\Varid{j}))\mathrel{=}matrix\;\Varid{j}\;\Varid{i}\;\underline{\Varid{k}}}
\more
\ensuremath{\Varid{g}\;(\Varid{a},(\Varid{b},(\Varid{c},\Varid{d})))\mathrel{=}(\Varid{a}\mathbin{<}}> b) <-> (c <\ensuremath{\mathbin{>}\Varid{d})}
\end{eqnarray*}

Assim, olhamos para o gene do \ensuremath{\Varid{cataQTree}\;\alt{\Varid{f}}{\Varid{g}}} e pensamos no que teremos
que alterar para a nossa função \ensuremath{\Varid{outlineQTree}} retornar uma \ensuremath{\Conid{Matrix}\;\Conid{Bool}}.
Sabemos que teremos que aplicar a função passada como parâmetro às \ensuremath{\Conid{Cell}}
de modo a saber se a mesma se trata de um píxel (conjunto de píxeis) de fundo.

Uma vez que é a \ensuremath{\Conid{Cell}} que contém os píxeis, no que diz respeito ao \ensuremath{\Conid{Block}}
nada precisará de ser feito. Logo, a função \ensuremath{\Varid{g}} será exatamente a mesma.

No caso das \ensuremath{\Conid{Cell}}, teremos então que dividir a função \ensuremath{\Varid{f}} em dois casos,
um deles quando após aplicada a função dada como parâmetro ao conteúdo da \ensuremath{\Conid{Cell}}
dá \ensuremath{\Conid{True}} e o segundo quando dá \ensuremath{\Conid{False}}:
\begin{enumerate}
\item \ensuremath{\Conid{True}}- contéudo da \ensuremath{\Conid{Cell}} ser um píxel de fundo:

Neste caso, sabemos que teremos que devolver uma \ensuremath{\Conid{Matrix}\;\Conid{Bool}} onde
o interior será \ensuremath{\Conid{False}} e o contorno \ensuremath{\Conid{True}}, por exemplo, para uma
Matriz de 4x4:
\begin{tabbing}\ttfamily
~\char40{}~True~True~~True~~True~\char41{}\\
\ttfamily ~\char40{}~True~False~False~True~\char41{}\\
\ttfamily ~\char40{}~True~False~False~True~\char41{}\\
\ttfamily ~\char40{}~True~True~~True~~True~\char41{}
\end{tabbing}

Logo, aproveitando a função \ensuremath{matrix}, usamos uma expressão lambda
onde se as coordenadas (x, y) da matriz pertencerem à borda da mesma,
ou seja, isso acontece quando \ensuremath{\Varid{x}\equiv \mathrm{1}} ou \ensuremath{\Varid{y}\equiv \mathrm{1}} ou \ensuremath{\Varid{x}\equiv \Varid{largura}\;\Varid{maxima}} ou
\ensuremath{\Varid{y}\equiv \Varid{altura}\;\Varid{maxima}}, o valor é \ensuremath{\Conid{True}}, caso contrário o valor será \ensuremath{\Conid{False}}.

\item \ensuremath{\Conid{False}}- O contéudo da \ensuremath{\Conid{Cell}} não ser um píxel de fundo:

Neste caso, basta aplicar a função \ensuremath{matrix} onde o conteúdo dos
elementos é \ensuremath{\Conid{False}}.

\end{enumerate}

Consequentemente, temos todos os dados para definir a nossa função \ensuremath{\Varid{outlineQTree}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{outlineQTree}\;\Varid{magic}\;\Varid{a}\mathrel{=}\Varid{cataQTree}\;\alt{\Varid{f}\;\Varid{magic}}{\Varid{g}}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{f}\;\Varid{magic}\;(\Varid{k},(\Varid{i},\Varid{j})){}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}\mid (\Varid{magic}\;\Varid{k})\mathrel{=}matrix\;\Varid{j}\;\Varid{i}\;(\lambda (\Varid{x},\Varid{y})\to \mathbf{if}\;(\Varid{x}\equiv \mathrm{1}\mathrel{\vee}\Varid{y}\equiv \mathrm{1}\mathrel{\vee}\Varid{x}\equiv \Varid{j}\mathrel{\vee}\Varid{y}\equiv \Varid{i})\;\mathbf{then}\;\Conid{True}\;\mathbf{else}\;\Conid{False}){}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}\mid \Varid{otherwise}\mathrel{=}matrix\;\Varid{j}\;\Varid{i}\;\underline{\Conid{False}}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{g}\;(\Varid{a},(\Varid{b},(\Varid{c},\Varid{d})))\mathrel{=}(\Varid{a}{\,\updownarrow\,}\Varid{b}){\,\leftrightarrow\,}(\Varid{c}{\,\updownarrow\,}\Varid{d}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{figure}
\begin{subfigure}{0.4\textwidth}
    \begin{center}
    \includegraphics[width=0.25\textwidth]{imgs/outline1.png}
    \end{center}
    \caption{Figura Person produzida com a função \ensuremath{\Varid{outlineBMP}}.}
    \label{fig:outline1}
\end{subfigure}
\begin{subfigure}{0.4\textwidth}
    \begin{center}
    \includegraphics[width=0.25\textwidth]{imgs/outline2.png}
    \end{center}
    \caption{Figura Person produzida com a função \ensuremath{\Varid{addOutlineBMP}}.}
    \label{fig:outline2}
\end{subfigure}
\end{figure}


No enunciado desta função era ainda sugerido que produzissemos imagens
com o auxílio de duas funções que utilizam a \ensuremath{\Varid{outlineQTree}}. As duas
imagens que obtivemos estão presentes na Figura~\ref{fig:outline1}
e a Figura~\ref{fig:outline2}.

\end{enumerate}


É ainda de salientar que todas as funções do problema passaram em todos os testes
do QuickCheck e nos Testes Unitários.

\subsection*{Problema 3}

O objetivo deste problema é derivar as funções \ensuremath{\Varid{base}\;\Varid{k}} e \ensuremath{\Varid{loop}} de modo a
podermos calcular as combinações de \ensuremath{\Varid{n}} \ensuremath{\Varid{k}}-a-\ensuremath{\Varid{k}},
\begin{eqnarray*}
	\ensuremath{\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\mathrel{=}\frac{{\Varid{n}!}}{{\Varid{k}!}\mathbin{*}{(\Varid{n}\mathbin{-}\Varid{k})!}}}
\end{eqnarray*}
recorrendo a um ciclo-for onde apenas se fazem multiplicações e somas:
\begin{eqnarray*}
    \ensuremath{\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\mathrel{=}\Varid{h}\;\Varid{k}\;(\Varid{n}\mathbin{-}\Varid{k})\;\mathbf{where}\;\Varid{h}\;\Varid{k}\;\Varid{n}\mathrel{=}\mathbf{let}\;(\Varid{a},\anonymous ,\Varid{b},\anonymous )\mathrel{=}\mathsf{for}\ \Varid{loop}\ (\Varid{base}\;\Varid{k})\;\Varid{n}\;\mathbf{in}\;\Varid{a}\mathbin{/}\Varid{b}}
\end{eqnarray*}

Tendo em conta o \ensuremath{\mathbf{where}\;\Varid{h}\;\Varid{k}\;\Varid{n}} e o \ensuremath{\mathbf{in}\;\Varid{a}\mathbin{/}\Varid{b}} da função acima apresentada
e comparando com a definição de \ensuremath{\Varid{h}\;\Varid{k}} do enunciado,
\begin{eqnarray*}
\start
       \ensuremath{\Varid{h}\;\Varid{k}\;\Varid{n}\mathrel{=}\frac{\Varid{f}\;\Varid{k}\;\Varid{n}}{\Varid{g}\;\Varid{n}}}
\more
       \ensuremath{\Varid{f}\;\Varid{k}\;\Varid{n}\mathrel{=}\frac{{(\Varid{n}\mathbin{+}\Varid{k})!}}{{\Varid{k}!}}}
\more
       \ensuremath{\Varid{g}\;\Varid{n}\mathrel{=}{\Varid{n}!}}
\end{eqnarray*}
constatamos que o nosso \material{a} em \ensuremath{\mathbf{in}\;\Varid{a}\mathbin{/}\Varid{b}} terá que ser a função
\ensuremath{\Varid{f}\;\Varid{k}} e o \material{b} será a função \ensuremath{\Varid{g}}.

Assim, para podermos descobrir a definição das funções pedidas (\ensuremath{\Varid{base}\;\Varid{k}} e \ensuremath{\Varid{loop}})
teremos que, a partir da definição de \ensuremath{\Varid{f}\;\Varid{k}} (e consequentemente de \ensuremath{\Varid{l}\;\Varid{k}}) e da definição
de \ensuremath{\Varid{g}} (e consequentemente de \ensuremath{\Varid{s}}), descobrirmos a definição de \ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}}
e de \ensuremath{\conj{\Varid{g}}{\Varid{s}}} (com recurso à lei da recursividade múltipla)
e posteriormente combinarmos os seus resultados com a lei de banana-split.

Para tal, dividimos o nosso problema em diferentes partes:

\begin{enumerate}
\item Determinar \ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}}

Para isso, tirando partido da indicação do enunciado, ou seja, com o intuito
de aplicar a lei da recursividade múltipla, temos:

\begin{eqnarray*}
\start
    \ensuremath{\begin{lcbr}\Varid{f}\;\Varid{k}\comp \mathbf{in}\mathrel{=}\Varid{o}\comp \Conid{F}\;\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\\\Varid{l}\;\Varid{k}\comp \mathbf{in}\mathrel{=}\Varid{p}\comp \Conid{F}\;\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\end{lcbr}}
%
\just\equiv{ Fokkinga: (50) }
%
\ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\mathrel{=}\cata{\conj{\Varid{o}}{\Varid{p}}}}
%
\end{eqnarray*}

O objetivo será então determinar \ensuremath{\Varid{o}} e \ensuremath{\Varid{p}} e, para isso, teremos que olhar
individualmente para cada uma das funções \ensuremath{\Varid{f}\;\Varid{k}} e \ensuremath{\Varid{l}\;\Varid{k}}, apresentadas no
enunciado:

\begin{enumerate}
\item Descobrir \ensuremath{\Varid{o}} (com a ajuda da função \ensuremath{\Varid{f}\;\Varid{k}})

\begin{eqnarray*}
\start
    \ensuremath{\begin{lcbr}\Varid{f}\;\Varid{k}\;\mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{f}\;\Varid{k}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\Varid{l}\;\Varid{k}\;\Varid{d})\mathbin{*}(\Varid{f}\;\Varid{k}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Def comp: (74) ; (*) escrita como função prefixo }
%
    \ensuremath{\begin{lcbr}\Varid{f}\;\Varid{k}\comp \mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{f}\;\Varid{k}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\mathbin{*})\;(\Varid{l}\;\Varid{k}\;\Varid{d})\;(\Varid{f}\;\Varid{k}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Igualdade extencional: (73) ; Def const: (76) }
%
    \ensuremath{\begin{lcbr}\Varid{f}\;\Varid{k}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{f}\;\Varid{k}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\mathbin{*})\;(\Varid{l}\;\Varid{k}\;\Varid{d})\;(\Varid{f}\;\Varid{k}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Definição de mul: mul (a, b) = (*) a b ;  }
%
    \ensuremath{\begin{lcbr}\Varid{f}\;\Varid{k}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{f}\;\Varid{k}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{mul}\;(\Varid{f}\;\Varid{k}\;\Varid{d},\Varid{l}\;\Varid{k}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Def split: (78) ; Def comp: (74) ; Definição de succ: succ d = d + 1 ; Igualdade extencional: (73) }
%
    \ensuremath{\begin{lcbr}\Varid{f}\;\Varid{k}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{f}\;\Varid{k}\comp (\succ )\mathrel{=}\Varid{mul}\comp \conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\end{lcbr}}
%
\just\equiv{ Eq + : (27) ; Natural id : (1) }
%
\ensuremath{\alt{\Varid{f}\;\Varid{k}\comp \underline{\mathrm{0}}}{\Varid{f}\;\Varid{k}\comp (\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}\comp \Varid{id}}{\Varid{mul}\comp \conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}}}
%
\just\equiv{ Fusão + : (20) ; Absorção x : (11) }
%
\ensuremath{\Varid{f}\;\Varid{k}\comp \alt{\underline{\mathrm{0}}}{(\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}}{\Varid{mul}}\comp (\Varid{id}\mathbin{+}\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}})}
%
\just\equiv{ Definição de in e functor (dos naturais): \ensuremath{\mathbf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{(\succ )}} , \ensuremath{\Conid{F}\;\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\mathrel{=}(\Varid{id}\mathbin{+}\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}})} }
%
\ensuremath{\Varid{f}\;\Varid{k}\comp \mathbf{in}\mathrel{=}\alt{\underline{\mathrm{1}}}{\Varid{mul}}\comp \Conid{F}\;\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}}
%
\end{eqnarray*}

Logo, \ensuremath{\Varid{o}\mathrel{=}\alt{\underline{\mathrm{1}}}{\Varid{mul}}}.


\item Descobrir \ensuremath{\Varid{p}} (com a ajuda da função \ensuremath{\Varid{l}\;\Varid{k}})
\begin{eqnarray*}
\start
    \ensuremath{\begin{lcbr}\Varid{l}\;\Varid{k}\;\mathrm{0}\mathrel{=}\Varid{k}\mathbin{+}\mathrm{1}\\\Varid{l}\;\Varid{k}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{l}\;\Varid{k}\;\Varid{d}\mathbin{+}\mathrm{1}\end{lcbr}}
%
\just\equiv{ Def comp: (74) }
%
    \ensuremath{\begin{lcbr}\Varid{l}\;\Varid{k}\comp \mathrm{0}\mathrel{=}\Varid{k}\mathbin{+}\mathrm{1}\\\Varid{l}\;\Varid{k}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{l}\;\Varid{k}\;\Varid{d}\mathbin{+}\mathrm{1}\end{lcbr}}
%
\just\equiv{ Definição de succ: succ d = d + 1 ; Def const: (76) ; Igualdade extencional: (73) }
%
    \ensuremath{\begin{lcbr}\Varid{l}\;\Varid{k}\comp \underline{\mathrm{0}}\mathrel{=}\underline{(\succ \;\Varid{k})}\\\Varid{l}\;\Varid{k}\comp (\succ )\mathrel{=}\succ \comp (\Varid{l}\;\Varid{k})\end{lcbr}}
%
\just\equiv{ Eq + : (27) ; Natural id : (1) }
%
\ensuremath{\alt{\Varid{l}\;\Varid{k}\comp \underline{\mathrm{0}}}{\Varid{l}\;\Varid{k}\comp (\succ )}\mathrel{=}\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \Varid{l}\;\Varid{k}}}
%
\just\equiv{ Natural id : (1) ; Cancelamento x : (7) }
%
\ensuremath{\alt{\Varid{l}\;\Varid{k}\comp \underline{\mathrm{0}}}{\Varid{l}\;\Varid{k}\comp (\succ )}\mathrel{=}\alt{\underline{(\succ \;\Varid{k})}\comp \Varid{id}}{\succ \comp \p2\comp \conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}}}
%
\just\equiv{ Fusão + : (20) ; Absorção x : (11) }
%
\ensuremath{\Varid{l}\;\Varid{k}\comp \alt{\underline{\mathrm{0}}}{(\succ )}\mathrel{=}\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}\comp (\Varid{id}\mathbin{+}\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}})}
%
\just\equiv{ Definição de in e functor (dos naturais): \ensuremath{\mathbf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{(\succ )}} , \ensuremath{\Conid{F}\;\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\mathrel{=}(\Varid{id}\mathbin{+}\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}})} }
%
\ensuremath{\Varid{l}\;\Varid{k}\comp \mathbf{in}\mathrel{=}\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}\comp \Conid{F}\;\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}}
%
\end{eqnarray*}

Logo, \ensuremath{\Varid{p}\mathrel{=}\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}}.

\vspace{0.5cm}

Deste modo, após encontrarmos a definição de \ensuremath{\Varid{o}} e de \ensuremath{\Varid{p}} conseguimos determinar
a definição de \ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}} uma vez que já haviamos concluido que
\ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\mathrel{=}\cata{\conj{\Varid{o}}{\Varid{p}}}}.

Logo, \ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}\mathrel{=}\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}}}}.
\end{enumerate}


\item Determinar \ensuremath{\conj{\Varid{g}}{\Varid{s}}}

Para descobrir \ensuremath{\conj{\Varid{g}}{\Varid{s}}} seguimos o mesmo raciocínio, isto é, tentamos
descobrir um \ensuremath{\Varid{v}} e um \ensuremath{\Varid{j}} de modo a podermos aplicar a lei da recursividade múltipla:

\begin{eqnarray*}
\start
    \ensuremath{\begin{lcbr}\Varid{g}\comp \mathbf{in}\mathrel{=}\Varid{v}\comp \Conid{F}\;\conj{\Varid{g}}{\Varid{s}}\\\Varid{s}\comp \mathbf{in}\mathrel{=}\Varid{j}\comp \Conid{F}\;\conj{\Varid{g}}{\Varid{s}}\end{lcbr}}
%
\just\equiv{ Fokkinga: (50) }
%
\ensuremath{\conj{\Varid{g}}{\Varid{s}}\mathrel{=}\cata{\conj{\Varid{v}}{\Varid{j}}}}
%
\end{eqnarray*}

\begin{enumerate}
\item Descobrir \ensuremath{\Varid{v}} (com a ajuda da função \ensuremath{\Varid{g}})

\begin{eqnarray*}
\start
    \ensuremath{\begin{lcbr}\Varid{g}\;\mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{g}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\Varid{g}\;\Varid{d})\mathbin{*}(\Varid{s}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Def comp: (74) ; (*) escrita como função prefixo }
%
    \ensuremath{\begin{lcbr}\Varid{g}\comp \mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{g}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\mathbin{*})\;(\Varid{g}\;\Varid{d})\;(\Varid{s}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Igualdade extencional: (73) ; Def const: (76) }
%
    \ensuremath{\begin{lcbr}\Varid{g}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{g}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}(\mathbin{*})\;(\Varid{g}\;\Varid{d})\;(\Varid{s}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Definição de mul: mul (a, b) = (*) a b ;  }
%
    \ensuremath{\begin{lcbr}\Varid{g}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{g}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{mul}\;(\Varid{g}\;\Varid{d},\Varid{s}\;\Varid{d})\end{lcbr}}
%
\just\equiv{ Def split: (78) ; Def comp: (74) ; Definição de succ: succ d = d + 1 ; Igualdade extencional: (73) }
%
    \ensuremath{\begin{lcbr}\Varid{g}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{g}\comp (\succ )\mathrel{=}\Varid{mul}\comp \conj{\Varid{g}}{\Varid{s}}\end{lcbr}}
%
\just\equiv{ Eq + : (27) ; Natural id : (1) }
%
\ensuremath{\alt{\Varid{g}\comp \underline{\mathrm{0}}}{\Varid{g}\comp (\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}\comp \Varid{id}}{\Varid{mul}\comp \conj{\Varid{g}}{\Varid{s}}}}
%
\just\equiv{ Fusão + : (20) ; Absorção x : (11) }
%
\ensuremath{\Varid{g}\comp \alt{\underline{\mathrm{0}}}{(\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}}{\Varid{mul}}\comp (\Varid{id}\mathbin{+}\conj{\Varid{g}}{\Varid{s}})}
%
\just\equiv{ Definição de in e functor (dos naturais): \ensuremath{\mathbf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{(\succ )}} , \ensuremath{\Conid{F}\;\conj{\Varid{g}}{\Varid{s}}\mathrel{=}(\Varid{id}\mathbin{+}\conj{\Varid{g}}{\Varid{s}}} }
%
\ensuremath{\Varid{g}\comp \mathbf{in}\mathrel{=}\alt{\underline{\mathrm{1}}}{\Varid{mul}}\comp \Conid{F}\;\conj{\Varid{g}}{\Varid{s}}}
%
\end{eqnarray*}

Logo, \ensuremath{\Varid{v}\mathrel{=}\alt{\underline{\mathrm{1}}}{\Varid{mul}}}.


\item Descobrir \ensuremath{\Varid{j}} (com a ajuda da função \ensuremath{\Varid{s}})
\begin{eqnarray*}
\start
    \ensuremath{\begin{lcbr}\Varid{s}\;\mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{s}\;(\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{s}\;\Varid{d}\mathbin{+}\mathrm{1}\end{lcbr}}
%
\just\equiv{ Def comp: (74) }
%
    \ensuremath{\begin{lcbr}\Varid{s}\comp \mathrm{0}\mathrel{=}\mathrm{1}\\\Varid{s}\comp (\Varid{d}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{s}\;\Varid{d}\mathbin{+}\mathrm{1}\end{lcbr}}
%
\just\equiv{ Definição de succ: succ d = d + 1 ; Def const: (76) ; Igualdade extencional: (73) }
%
    \ensuremath{\begin{lcbr}\Varid{s}\comp \underline{\mathrm{0}}\mathrel{=}\underline{\mathrm{1}}\\\Varid{s}\comp (\succ )\mathrel{=}\succ \comp \Varid{s}\end{lcbr}}
%
\just\equiv{ Eq + : (27) ; Natural id : (1) }
%
\ensuremath{\alt{\Varid{s}\comp \underline{\mathrm{0}}}{\Varid{s}\comp (\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}}{\succ \comp \Varid{s}}}
%
\just\equiv{ Natural id : (1) ; Cancelamento x : (7) }
%
\ensuremath{\alt{\Varid{s}\comp \underline{\mathrm{0}}}{\Varid{s}\comp (\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}\comp \Varid{id}}{\succ \comp \p2\comp \conj{\Varid{g}}{\Varid{s}}}}
%
\just\equiv{ Fusão + : (20) ; Absorção x : (11) }
%
\ensuremath{\Varid{s}\comp \alt{\underline{\mathrm{0}}}{(\succ )}\mathrel{=}\alt{\underline{\mathrm{1}}}{\succ \comp \p2}\comp (\Varid{id}\mathbin{+}\conj{\Varid{s}}{\Varid{g}})}
%
\just\equiv{ Definição de in e functor (dos naturais): \ensuremath{\mathbf{in}\mathrel{=}\alt{\underline{\mathrm{0}}}{(\succ )}} , \ensuremath{\Conid{F}\;(\conj{\Varid{s}}{\Varid{g}}\mathrel{=}(\Varid{id}\mathbin{+}\conj{\Varid{s}}{\Varid{g}})} }
%
\ensuremath{\Varid{s}\comp \mathbf{in}\mathrel{=}\alt{\underline{\mathrm{1}}}{\succ \comp \p2}\comp \Conid{F}\;\conj{\Varid{s}}{\Varid{g}}}
%
\end{eqnarray*}

Logo, \ensuremath{\Varid{j}\mathrel{=}\alt{\underline{\mathrm{1}}}{\succ \comp \p2}}.

\vspace{0.5cm}

Deste modo, após encontrarmos a definição de \ensuremath{\Varid{v}} e de \ensuremath{\Varid{j}} conseguimos determinar
a definição de \ensuremath{\conj{\Varid{g}}{\Varid{s}}} uma vez que já haviamos constatado que
\ensuremath{\conj{\Varid{g}}{\Varid{s}}\mathrel{=}\cata{\conj{\Varid{v}}{\Varid{j}}}}.

Logo, \ensuremath{\conj{\Varid{g}}{\Varid{s}}\mathrel{=}\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{\mathrm{1}}}{\succ \comp \p2}}}}.
\end{enumerate}


\item Aplicar a lei de banana split à definição de \ensuremath{\conj{\Varid{f}\;\Varid{k}}{\Varid{l}\;\Varid{k}}} e \ensuremath{\conj{\Varid{g}}{\Varid{s}}}

A lei de banana split (51) é a seguinte:
\begin{eqnarray*}
\start
\ensuremath{\conj{\cata{\Varid{i}}}{\cata{\Varid{j}}}}
%
\just\equiv{ Banana-split : (51) }
%
\ensuremath{\cata{(\Varid{i}\times\Varid{j})\comp \conj{\Conid{F}\;\p1}{\Conid{F}\;\p2}}}
%
\end{eqnarray*}

Assim, podemos constatar que, no nosso caso:
\begin{eqnarray*}
\ensuremath{\cata{\Varid{i}}\mathrel{=}\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}}}}
\end{eqnarray*}
e
\begin{eqnarray*}
\ensuremath{\cata{\Varid{j}}\mathrel{=}\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{\mathrm{1}}}{\succ \comp \p2}}}}
\end{eqnarray*}


Assim, retomando o resultado anterior e aplicando a lei temos:
\begin{eqnarray*}
\start
\ensuremath{\conj{\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}}}}{\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{\mathrm{1}}}{\succ \comp \p2}}}}}
%
\just\equiv{ Banana-split : (51) }
%
\ensuremath{\cata{(\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}}}\times\cata{\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{\mathrm{1}}}{\succ \comp \p2}}})\comp \conj{\Conid{F}\;\p1}{\Conid{F}\;\p2}}}
%
\end{eqnarray*}

Agora podemos então continuar a resolver o problema, sempre com o intuito de chegar
a um \ensuremath{\cata{\alt{\Varid{b}}{\Varid{i}}}} para podermos aplicar a definição de ciclo for:
\begin{eqnarray*}
\ensuremath{\mathsf{for}\ \Varid{b}\ \underline{\Varid{i}}\mathrel{=}\cata{\alt{\Varid{i}}{\Varid{b}}}}
\end{eqnarray*}

\vspace{0.5cm}

Retomando o resultado anterior e continuando a aplicar as leis do cálculo de programas, temos:
\begin{eqnarray*}
\start
\ensuremath{\cata{(\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{(\succ \;\Varid{k})}}{\succ \comp \p2}}\times\conj{\alt{\underline{\mathrm{1}}}{\Varid{mul}}}{\alt{\underline{\mathrm{1}}}{\succ \comp \p2}})\comp \conj{\Conid{F}\;\p1}{\Conid{F}\;\p2}}}
%
\just\equiv{ Absorção x : (11) ; Lei da troca : (28) }
%
\ensuremath{\cata{\conj{\alt{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\Varid{mul}}{\succ \comp \p2}}\comp \Conid{F}\;\p1}{\alt{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}{\conj{\Varid{mul}}{\succ \comp \p2}}\comp \Conid{F}\;\p2}}}
%
\just\equiv{ Definição do Functor (dos naturais): \ensuremath{\Conid{F}\;\p1\mathrel{=}\Varid{id}\mathbin{+}\p1}, \ensuremath{\Conid{F}\;\p2\mathrel{=}\Varid{id}\mathbin{+}\p2} }
%
\ensuremath{\cata{\conj{\alt{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\Varid{mul}}{\succ \comp \p2}}\comp (\Varid{id}\mathbin{+}\p1)}{\alt{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}{\conj{\Varid{mul}}{\succ \comp \p2}}\comp (\Varid{id}\mathbin{+}\p2)}}}
%
\just\equiv{ Absorção + : (22) x2 ; Fusão x : (10) x2 ; Natural id : (1) x2 }
%
\ensuremath{\cata{\conj{\alt{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}}{\alt{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}}}}
%
\just\equiv{ Lei da troca : (28) }
%
\ensuremath{\cata{\alt{\conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}}{\conj{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}}}}
%
\just\equiv{ Definição de for: \ensuremath{\mathsf{for}\ \Varid{b}\ \underline{\Varid{i}}\mathrel{=}\cata{\alt{\Varid{i}}{\Varid{b}}}} }
%
\ensuremath{\mathsf{for}\ \conj{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}\ \conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}}
\end{eqnarray*}


Assim, tendo em conta a definição do enunciado:
\begin{eqnarray*}
\ensuremath{\mathsf{for}\ \Varid{loop}\ (\Varid{base}\;\Varid{k})}
\end{eqnarray*}

E comparando com o nosso resultado:
\begin{eqnarray*}
\ensuremath{\mathsf{for}\ \conj{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}\ \conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}}
\end{eqnarray*}

Temos que:
\begin{eqnarray*}
\start
\ensuremath{\Varid{loop}\mathrel{=}\conj{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}}
\more
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}\conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}}
\end{eqnarray*}

\item Derivar a definição de \ensuremath{\Varid{base}\;\Varid{k}}

Focando em \ensuremath{\Varid{base}\;\Varid{k}}:
\begin{eqnarray*}
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}\conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}}
\end{eqnarray*}

Vamos agora introduzir variáveis à definição \ensuremath{\Varid{pointfree}} para
podermos ter o resultado da função \ensuremath{\Varid{base}\;\Varid{k}} em haskell.

Uma vez que o tipo de split, por exemplo, \ensuremath{\conj{\Varid{id}}{\Varid{id}}} é:
\hfill \break
\xymatrix@C=20cm{
    \ensuremath{\Conid{A}}
           \ar[d]_-{\ensuremath{\conj{\Varid{id}}{\Varid{id}}}}
\\
    \ensuremath{\Conid{A}\times\Conid{A}}
}
\hfill \break

O tipo de \ensuremath{\conj{\conj{\Varid{id}}{\Varid{id}}}{\conj{\Varid{id}}{\Varid{id}}}} será:
\hfill \break
\xymatrix@C=20cm{
    \ensuremath{\Conid{A}}
           \ar[d]_-{\ensuremath{\conj{\conj{\Varid{id}}{\Varid{id}}}{\conj{\Varid{id}}{\Varid{id}}}}}
\\
    \ensuremath{(\Conid{A}\times\Conid{A})\times(\Conid{A}\times\Conid{A})}
}
\hfill \break

Assim, conseguimos perceber qual é o tipo da variável que temos que adicionar
uma vez que no nosso caso também se trata de um split de split.

Logo, continuando a derivação:
\begin{eqnarray*}
\start
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}\conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}}
%
\just\equiv{ Igualdade extensional : (73)  }
%
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}\conj{\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}}{\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}}\;\Varid{a}}
%
\just\equiv{ Def split : (78) }
%
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}(\conj{\underline{\mathrm{1}}}{\underline{(\succ \;\Varid{k})}}\;\Varid{a},\conj{\underline{\mathrm{1}}}{\underline{\mathrm{1}}}\;\Varid{a})}
%
\just\equiv{ Def split : (78) x2 }
%
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}((\underline{\mathrm{1}}\;\Varid{a},\underline{(\succ \;\Varid{k})}\;\Varid{a}),(\underline{\mathrm{1}}\;\Varid{a},\underline{\mathrm{1}}\;\Varid{a}))}
%
\just\equiv{ Def const : (76) x4 ; Definição de succ: succ k = k + 1 }
%
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}((\mathrm{1},\Varid{k}\mathbin{+}\mathrm{1}),(\mathrm{1},\mathrm{1}))}
%
\end{eqnarray*}

Porém, tendo em consideração a implementação desejada:
\begin{eqnarray*}
    \ensuremath{\Big(\vcenter{\xymatrix@R=1pt{\Varid{n}\\\Varid{k}}}\Big)\mathrel{=}\Varid{h}\;\Varid{k}\;(\Varid{n}\mathbin{-}\Varid{k})\;\mathbf{where}\;\Varid{h}\;\Varid{k}\;\Varid{n}\mathrel{=}\mathbf{let}\;(\Varid{a},\anonymous ,\Varid{b},\anonymous )\mathrel{=}\mathsf{for}\ \Varid{loop}\ (\Varid{base}\;\Varid{k})\;\Varid{n}\;\mathbf{in}\;\Varid{a}\mathbin{/}\Varid{b}}
\end{eqnarray*}

Vemos que em \ensuremath{\mathbf{let}\;(\Varid{a},\anonymous ,\Varid{b},\anonymous )} o tipo de dados é um quádruplo o que implica que
os tipos de \ensuremath{\Varid{loop}} e \ensuremath{\Varid{base}\;\Varid{k}}, mais especificamente
o tipo de retorno, terão que ser também um quádruplo (o \ensuremath{\mathsf{for}\ \Varid{loop}\ (\Varid{base}\;\Varid{k})\;\Varid{n}}, por sua vez,
também deverá retornar um quádruplo).

Deste modo, através da aplicação de uma simples função que nos altere o tipo de dados, por exemplo:
\begin{eqnarray*}
\start
\ensuremath{\Varid{altera}\mathbin{::}((\Varid{a},\Varid{b}),(\Varid{c},\Varid{d}))\to (\Varid{a},\Varid{b},\Varid{c},\Varid{d})}
\more
\ensuremath{\Varid{altera}\;((\Varid{a},\Varid{b}),(\Varid{c},\Varid{d}))\mathrel{=}(\Varid{a},\Varid{b},\Varid{c},\Varid{d})}
\end{eqnarray*}

Conseguimos ter a derivação desejada da função \ensuremath{\Varid{base}\;\Varid{k}}:
\begin{eqnarray*}
\ensuremath{\Varid{base}\;\Varid{k}\mathrel{=}(\mathrm{1},\Varid{k}\mathbin{+}\mathrm{1},\mathrm{1},\mathrm{1})}
\end{eqnarray*}

\item Derivar a definição de \ensuremath{\Varid{loop}}

Por último, para derivar a definição de \ensuremath{\Varid{loop}} teremos que pensar da mesma forma, ou seja,
inserir variáveis. Porém, ao contrário da função \ensuremath{\Varid{base}\;\Varid{k}}, as variáveis a inserir terão que ser
do tipo ((a, b), (c, d)) uma vez que temos um split com projeções \ensuremath{\p1} e \ensuremath{\p2}.
Nos diagramas abaixo pode-se verificar o motivo desta diferença de domínio:

Tendo em conta o primeiro split do split maior, temos:
\hfill \break
\xymatrix@C=5cm{
    \ensuremath{(\Conid{A}\times\mathit B)\times(\mathit C\times\Conid{D})}
           \ar[d]_-{\ensuremath{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}}
\\
    \ensuremath{\Conid{Z}\times\mathit B}
}
\hfill \break

É de salientar que o tipo mul (a, b) = a * b, ou seja, o tipo desta função é:
\hfill \break
\xymatrix@C=5cm{
    \ensuremath{(\Conid{A}\times\mathit B)}
           \ar[d]_-{\ensuremath{\Varid{mul}}}
\\
    \ensuremath{\Conid{Z}}
}
\hfill \break


Tendo agora em consideração o segundo split do split maior, temos:
\hfill \break
\xymatrix@C=5cm{
    \ensuremath{(\Conid{A}\times\mathit B)\times(\mathit C\times\Conid{D})}
           \ar[d]_-{\ensuremath{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}}
\\
    \ensuremath{(\Conid{Z}\times\Conid{D})}
}
\hfill \break


Temos então,
\begin{eqnarray*}
\start
\ensuremath{\Varid{loop}\mathrel{=}\conj{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}}
%
\just\equiv{ Igualdade extensional : (73)  }
%
\ensuremath{\Varid{loop}\mathrel{=}\conj{\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}}{\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}}\;((\Varid{a},\Varid{b}),(\Varid{c},\Varid{d}))}
%
\just\equiv{ Def split : (78) }
%
\ensuremath{\Varid{loop}\mathrel{=}(\conj{\Varid{mul}\comp \p1}{\succ \comp \p2\comp \p1}\;((\Varid{a},\Varid{b}),(\Varid{c},\Varid{d})),\conj{\Varid{mul}\comp \p2}{\succ \comp \p2\comp \p2}\;((\Varid{a},\Varid{b}),(\Varid{c},\Varid{d})))}
%
\just\equiv{ Def split : (78) x2 ; Def comp : (74) x6 ; Def proj : (81) x6 }
%
\ensuremath{\Varid{loop}\mathrel{=}((\Varid{mul}\;(\Varid{a},\Varid{b}),\succ \;\Varid{b}),(\Varid{mul}\;(\Varid{c},\Varid{d}),\succ \;\Varid{d}))}
%
\just\equiv{ Definição de succ : succ k = k + 1  x2 ; Definição de mul : mul (m,n) = m * n x2 }
%
\ensuremath{\Varid{loop}\mathrel{=}((\Varid{a}\mathbin{*}\Varid{b},\Varid{b}\mathbin{+}\mathrm{1}),(\Varid{c}\mathbin{*}\Varid{d},\Varid{d}\mathbin{+}\mathrm{1}))}
%
\end{eqnarray*}

Deparámo-nos com o mesmo problema da função \ensuremath{\Varid{base}\;\Varid{k}} e por isso vamos aplicar novamente a função
\ensuremath{\Varid{altera}} para reparar o tipo de dados de retorno. Temos então:
\begin{eqnarray*}
\ensuremath{\Varid{loop}\;(\Varid{a},\Varid{b},\Varid{c},\Varid{d})\mathrel{=}(\Varid{a}\mathbin{*}\Varid{b},\Varid{b}\mathbin{+}\mathrm{1},\Varid{c}\mathbin{*}\Varid{d},\Varid{d}\mathbin{+}\mathrm{1})}
\end{eqnarray*}

\end{enumerate}


Deste modo, obtemos os dois resultados pretendidos:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{base}\;\Varid{k}\mathrel{=}(\mathrm{1},\Varid{k}\mathbin{+}\mathrm{1},\mathrm{1},\mathrm{1}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{loop}\;(\Varid{a},\Varid{b},\Varid{c},\Varid{d})\mathrel{=}(\Varid{a}\mathbin{*}\Varid{b},\Varid{b}\mathbin{+}\mathrm{1},\Varid{c}\mathbin{*}\Varid{d},\Varid{d}\mathbin{+}\mathrm{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 4}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{inFTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{outFTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{baseFTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{recFTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{cataFTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{anaFTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{hyloFTree}\mathrel{=}\bot {}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Bifunctor}\;\Conid{FTree}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{bimap}\mathrel{=}\bot {}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{generatePTree}\mathrel{=}\bot {}\<[E]%
\\
\>[B]{}\Varid{drawPTree}\mathrel{=}\bot {}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 5}

O quinto e último problema diz respeito a \ensuremath{\Varid{monades}}. O mónade do
problema é conhecido por \emph{bag}, \emph{saco}
ou \emph{multi-conjunto}, permitindo que os elementos de um
conjunto tenham multiplicidades associadas.

Para este problema o objetivo é que completemos a definição
de \ensuremath{\Conid{Monad}\;\Conid{Bag}}, nomeadamente no que diz respeito
ao \ensuremath{\mu } (multiplicação do mónade \ensuremath{\Conid{Bag}}) e a respetiva
função auxiliar \ensuremath{\Varid{singletonbag}}. É também necessário definir
a função \ensuremath{\Varid{dist}}.

\vspace{0.4cm}

Começando pela função \ensuremath{\Varid{singletonbag}}, tal como o próprio nome indica,
o objetivo dela é ter um saco com apenas um elemento do valor passado como
parâmetro, para ser o \ensuremath{\Varid{return}} do \ensuremath{\Conid{Monad}}.

Assim, a sua definição é intuitiva e é a seguinte:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{singletonbag}\;\Varid{a}\mathrel{=}\mathit B\;[\mskip1.5mu (\Varid{a},\mathrm{1})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

É o construtor \ensuremath{\mathit B} que se encarrega de fazer com que o
tipo de retorno de \ensuremath{\Varid{singletonbag}} seja o desejado.

\vspace{0.3cm}

Quanto ao \ensuremath{\mu }, sabemos que o seu tipo de dados deverá ser o seguinte:
\begin{eqnarray*}
\ensuremath{\mu \mathbin{::}\Conid{Bag}\;(\Conid{Bag}\;\Varid{a})\to \Conid{Bag}\;\Varid{a}}
\end{eqnarray*}

Deste modo, tendo ainda em consideração a definição de \ensuremath{\Conid{Monad}}
sabemos que esta função recebe um Bag de Bags, como por
exemplo:
\begin{eqnarray*}
\start
\ensuremath{\Varid{b2}\mathbin{::}\Conid{Bag}\;(\Conid{Bag}\;\Conid{Marble})}
\more
\ensuremath{\Varid{b2}\mathrel{=}\mathit B\;[\mskip1.5mu (\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{2}),(\Conid{Green},\mathrm{3}),(\Conid{Red},\mathrm{2}),(\Conid{Blue},\mathrm{2}),(\Conid{White},\mathrm{1})\mskip1.5mu],\mathrm{5})}
\more
\ensuremath{,(\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{1}),(\Conid{Green},\mathrm{2}),(\Conid{Red},\mathrm{1}),(\Conid{Blue},\mathrm{1})\mskip1.5mu],\mathrm{2})\mskip1.5mu]}
\end{eqnarray*}

E que o objetivo é que a função retorne um Bag somente, que, no
caso de correr \ensuremath{\mu \;\Varid{b2}} deverá ser:
\begin{eqnarray*}
\start
\ensuremath{\Varid{b1}\mathbin{::}\Conid{Bag}\;\Conid{Marble}}
\more
\ensuremath{\Varid{b1}\mathrel{=}\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{12}),(\Conid{Green},\mathrm{19}),(\Conid{Red},\mathrm{12}),(\Conid{Blue},\mathrm{12}),(\Conid{White},\mathrm{5})\mskip1.5mu]}
\end{eqnarray*}

Sucintamente, o objetivo do \ensuremath{\mu } é que dado um Bag com Bags lá dentro
todos os seus elementos se juntem num só Bag. Para tal, é necessário
ter em atenção quantos Bags estão dentro do Bag maior e
agrupar convenientemente os seus conteúdos,
tal como vimos no exemplo anterior.

Assim, com recurso a algumas funções auxiliares produzimos o código
em seguida:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mu \;\Varid{b}\mathrel{=}\mathit B\;(\Varid{concat}\;(\mathsf{fmap}\;\Varid{unB}\;(\Varid{junta}\;(\Varid{unB}\;\Varid{b})))){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{junta}\;((\Varid{ba},\Varid{int})\mathbin{:}\Varid{bas})\mathrel{=}(\Varid{fmapSpecial}\;(\mathbin{*}\Varid{int})\;\Varid{ba})\mathbin{:}(\Varid{junta}\;\Varid{bas}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{junta}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{fmapSpecial}\;\Varid{f}\mathrel{=}\mathit B\comp \map \;(\Varid{id}\times\Varid{f})\comp \Varid{unB}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

O diagrama seguinte mostra as alterações nos tipos de dados que vão
acontecendo no decorrer da definição de \ensuremath{\mu } por nós proposta:
\begin{eqnarray*}
\xymatrix@C=5cm{
    \ensuremath{\Conid{Bag}\;(\Conid{Bag}\;\Varid{a})}
        \ar[d]_-{\ensuremath{\Varid{unB}}}
\\
    \ensuremath{[\mskip1.5mu (\Conid{Bag}\;\Varid{a},\Conid{Int})\mskip1.5mu]}
        \ar[d]_-{\ensuremath{\Varid{junta}}}
\\
    \ensuremath{[\mskip1.5mu \Conid{Bag}\;\Varid{a}\mskip1.5mu]}
        \ar[d]_-{\ensuremath{\mathsf{fmap}\;\Varid{unB}}}
\\
    \ensuremath{[\mskip1.5mu [\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]\mskip1.5mu]}
        \ar[d]_-{\ensuremath{\Varid{concat}}}
\\
    \ensuremath{[\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]}
        \ar[d]_-{\ensuremath{\mathit B}}
\\
    \ensuremath{\Conid{Bag}\;\Varid{a}}
}
\end{eqnarray*}

Passando a explicar por palavras passo a passo
o que acontece na função \ensuremath{\mu }, temos que:
\begin{enumerate}
\item \ensuremath{\Varid{un}\;\mathit B}

Numa primeira fase ``desembrulhamos'' o Bag de Bags, passando agora
a ter uma lista com \ensuremath{(\Conid{Bag}\;\Varid{a},\Conid{Int})} onde poderemos iterar mais facilmente
sobre os elementos.

\item \ensuremath{\Varid{junta}}

Esta função, com a ajuda de uma função auxiliar chamada \ensuremath{\Varid{fmapSpecial}},
transforma a lista de \ensuremath{(\Conid{Bag}\;\Varid{a})\times\Conid{Int}}, sendo que este Int
representa o número de ``sacos'' que existem de \ensuremath{\Conid{Bag}\;\Varid{a}}, numa só lista de \ensuremath{\Conid{Bag}\;\Varid{a}}.
A função multiplica o número de sacos que existem daquele tipo pelo conteúdo
dentro do \ensuremath{\Conid{Bag}\;\Varid{a}}. Ou seja, se temos 3 sacos com 2 berlindes azuis
dentro de cada um sabemos que no total temos 6 berlindes azuis, e é exatamente
isso que a função faz dentro de cada \ensuremath{\Conid{Bag}\;\Varid{a}} da lista.

\item \ensuremath{\mathsf{fmap}\;\Varid{unB}}

Este passo ``abre'' todos os \ensuremath{\Conid{Bag}\;\Varid{a}} dentro de \ensuremath{[\mskip1.5mu \Conid{Bag}\;\Varid{a}\mskip1.5mu]}, ficando agora
com o tipo \ensuremath{[\mskip1.5mu [\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]\mskip1.5mu]}. Mais uma vez, este passo é feito
para facilitar o manuseamento dos elementos.

\item \ensuremath{\Varid{concat}}

Esta função, já predefinida, é responsável por concatenar a \ensuremath{[\mskip1.5mu [\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]\mskip1.5mu]}
em \ensuremath{[\mskip1.5mu (\Varid{a},\Conid{Int})\mskip1.5mu]}. O que esta função faz é somente juntar os pares \ensuremath{(\Varid{a},\Conid{Int})}
numa só lista.

\item \ensuremath{\mathit B}

Neste último passo é aplicado o construtor de \ensuremath{\Conid{Bag}} à lista de \ensuremath{(\Varid{a},\Conid{Int})} e com
isso fica garantido que os \ensuremath{(\Varid{a},\Conid{Int})} repetidos se juntam, somando
os respetivos \ensuremath{\Conid{Int}}, e que o tipo
de dados de retorno é o tipo desejado, nomeadamente \ensuremath{\Conid{Bag}\;\Varid{a}}.

\end{enumerate}

\vspace{0.3cm}

Para a função \ensuremath{\Varid{dist}}, tendo em consideração o exemplo dado no enunciado, onde para o
``saco'':
\begin{eqnarray*}
\ensuremath{\mathit B\;[\mskip1.5mu (\Conid{Pink},\mathrm{2}),(\Conid{Green},\mathrm{3}),(\Conid{Red},\mathrm{2}),(\Conid{Blue},\mathrm{2}),(\Conid{White},\mathrm{1})\mskip1.5mu]}
\end{eqnarray*}
O resultado da aplicação desta função deverá ser:
\begin{tabbing}\ttfamily
~Green~~30\char46{}0\char37{}\\
\ttfamily ~~~Red~~20\char46{}0\char37{}\\
\ttfamily ~~Pink~~20\char46{}0\char37{}\\
\ttfamily ~~Blue~~20\char46{}0\char37{}\\
\ttfamily ~White~~10\char46{}0\char37{}
\end{tabbing}
Percebemos que \ensuremath{\Varid{dist}} divide o número de elementos de cada elemento
pelo número total de elementos.

Assim, definimos a função como:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{dist}\;(\mathit B\;\Varid{a})\mathrel{=}\Conid{D}\;((\map \;(\lambda (\Varid{x},\Varid{y})\to (\Varid{x},(\mathbin{/})\;(\Varid{toFloat}\;\Varid{y})\;(\Varid{toFloat}\;(\Varid{number}\;\Varid{a})))))\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{number}\;[\mskip1.5mu \mskip1.5mu]\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{number}\;((\anonymous ,\Varid{int})\mathbin{:}\Varid{cs})\mathrel{=}\Varid{int}\mathbin{+}\Varid{number}\;\Varid{cs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A função percorre todos os elementos de \ensuremath{\mathit B\;\Varid{a}} (\ensuremath{[\mskip1.5mu \Varid{a},\Conid{Int}\mskip1.5mu]}, mais especificamente,
uma vez que é este o parâmetro que passamos ao \ensuremath{\map })
e divide cada Int pelo número total de elementos do conjunto, que é calculado
com a ajuda da função auxiliar \ensuremath{\Varid{number}}.

De modo a retornarmos o resultado da forma correta, nomeadamente \ensuremath{\fun{Dist}\;\Varid{a}},
tivemos que fazer duas pequenas alterações no código: a primeira foi converter
o \ensuremath{\Varid{y}} e o \ensuremath{\Varid{number}\;\Varid{a}} (numero total de berlindes) de cada par para \ensuremath{\Conid{Float}} antes de os
dividirmos. A segunda é aplicar o construtor \ensuremath{\Conid{D}}, do módulo \ensuremath{\Conid{Probability}},
ao resultado do \ensuremath{\map }
para assim conseguirmos obter o tipo de dados desejado.


\section{Como exprimir cálculos e diagramas em LaTeX/lhs2tex}
Estudar o texto fonte deste trabalho para obter o efeito:\footnote{Exemplos tirados de \cite{Ol18}.}
\begin{eqnarray*}
\start
	\ensuremath{\Varid{id}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}
%
\just\equiv{ universal property }
%
        \ensuremath{\begin{lcbr}\p1\comp \Varid{id}\mathrel{=}\Varid{f}\\\p2\comp \Varid{id}\mathrel{=}\Varid{g}\end{lcbr}}
%
\just\equiv{ identity }
%
        \ensuremath{\begin{lcbr}\p1\mathrel{=}\Varid{f}\\\p2\mathrel{=}\Varid{g}\end{lcbr}}
\qed
\end{eqnarray*}

Os diagramas podem ser produzidos recorrendo à \emph{package} \LaTeX\
\href{https://ctan.org/pkg/xymatrix}{xymatrix}, por exemplo:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
           \ar[d]_-{\ensuremath{\cata{\Varid{g}}}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\cata{\Varid{g}}}}
           \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
     \ensuremath{\mathit B}
&
     \ensuremath{\mathrm{1}\mathbin{+}\mathit B}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

%----------------- Fim do anexo com soluções dos alunos ------------------------%

%----------------- Índice remissivo (exige makeindex) -------------------------%

\printindex

%----------------- Outras definições auxiliares -------------------------------------------%


%----------------- Fim do documento -------------------------------------------%

\end{document}
